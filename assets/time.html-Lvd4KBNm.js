import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,o as a,d as n}from"./app-B5m7CcSj.js";const s={},t=n(`<h2 id="flink中的时间语义" tabindex="-1"><a class="header-anchor" href="#flink中的时间语义"><span>Flink中的时间语义</span></a></h2><p>在现实世界中，数据不可能会像理想中的那样，来一条就处理一条，反而是各种网络故障、数据延迟、乱序等问题更多更常态化一些。</p><p>为了更精准地处理数据流，<a href="https://flink.apache.org/" target="_blank" rel="noopener noreferrer">Flink</a>定义了三种不同的时间语义（<a href="https://nightlies.apache.org/flink/flink-docs-master/docs/concepts/time/" target="_blank" rel="noopener noreferrer">时间在Flink流处理中的意义</a>）。</p><ul><li><p><code>处理时间（Processing Time）</code>：是执行<a href="https://flink.apache.org/" target="_blank" rel="noopener noreferrer">Flink</a>计算的机器的系统时间，可能是某台独立部署的机器，也可能是集群中的某一台。它不需要和其他机器协调或同步，在哪台机器上，就以哪台机器的时间为准。</p></li><li><p><code>事件时间（Event Time）</code>：是指每条数据记录产生时的自然时间，也就是记录生成的时间，例如监控探头生成的报警记录时间、银行ATM机生成的转账时间，短视频上传时间等。这种时间和<a href="https://flink.apache.org/" target="_blank" rel="noopener noreferrer">Flink</a>所在的机器本身的时间无关，而且它一定是有序的。</p></li><li><p><code>摄入时间（Ingestion Time）</code>：摄入时间，类似于某人吃了东西，虽然吃进嘴里但还没开始消化。摄入就是指东西吃到嘴里的时间，也是指数据进入到<a href="https://flink.apache.org/" target="_blank" rel="noopener noreferrer">Flink</a>但还没开始处理的时间。</p></li></ul><p>官网给出的这幅图非常清楚地指明了这三种时间语义的不同。</p><figure><img src="https://tianmazuo.com/technology/bigdata/flink/flink-04.png" alt="Flink中三种不同的时间语义" tabindex="0" loading="lazy"><figcaption>Flink中三种不同的时间语义</figcaption></figure><p>可以明确地在代码中告诉<a href="https://flink.apache.org/" target="_blank" rel="noopener noreferrer">Flink</a>需要采取哪种时间语义执行运算。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">package</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;"> itechthink.window</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> org.apache.flink.streaming.api.TimeCharacteristic</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">/**</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> * Flink三种不同的时间语义</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> *</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> */</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> FlinkTimeExample</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Exception</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        StreamExecutionEnvironment</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> env</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> StreamExecutionEnvironment</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getExecutionEnvironment</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        // 设置事件时间语义</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        env</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setStreamTimeCharacteristic</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">TimeCharacteristic</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">EventTime</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        // 或者设置接收时间语义</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        // env.setStreamTimeCharacteristic(TimeCharacteristic.IngestionTime);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        // 或者设置处理时间语义</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        // env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        // 构建数据流的其余部分</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        // ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        env</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">execute</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Flink Time Example&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>凡事有好有坏，这几种不同的时间语义也各有利弊。</p><h3 id="处理时间-processing-time" tabindex="-1"><a class="header-anchor" href="#处理时间-processing-time"><span>处理时间（Processing Time）</span></a></h3><p>最为简单直接，完全不需要流和机器之间的协调，提供最佳性能和最低延迟。但在时间敏感，尤其是在银行、保险、证券、传媒等这些建立在完全时间序列之上的业务中，这种时间语义是不可接受的。</p><p>这种时间语义下的处理结果，有一定的随机性，因为它会受数据到达系统的先后、网络延迟、系统宕机、黑客攻击等各种因素的影响。</p><p>这种时间语义下，<a href="https://flink.apache.org/" target="_blank" rel="noopener noreferrer">Flink</a>会按最便于计算的方式来划分时间区间。</p><p>例如，如果<a href="https://flink.apache.org/" target="_blank" rel="noopener noreferrer">Flink</a>在<code>9:20</code>开始作业，那么第1个小时的作业区间是<code>[9:20, 10:00)</code>，下一个作业的时间区间会是<code>[10:00, 11:00)</code>，再下一个是<code>[11:00, 12:00)</code>，依此类推。</p><p><code>[</code>和<code>)</code>是数学集合中的概念，表示区间的开闭。<code>[</code>表示左闭区间，它包含下界数字，<code>)</code>表示右开区间，它不包含上界数字，<code>[9:20, 10:00)</code>表示处理<code>9:20</code>时间点上的数据，但不处理<code>10:00</code>时间点上的数据。</p><p>以下均同。</p><h3 id="事件时间-event-time" tabindex="-1"><a class="header-anchor" href="#事件时间-event-time"><span>事件时间（Event Time）</span></a></h3><p>这种时间会随着数据一同进入<a href="https://flink.apache.org/" target="_blank" rel="noopener noreferrer">Flink</a>参与计算，<a href="https://flink.apache.org/" target="_blank" rel="noopener noreferrer">Flink</a>可以单独提取它。在理想情况下，<a href="https://flink.apache.org/" target="_blank" rel="noopener noreferrer">Flink</a>可以按照这个时间顺序来依次处理每一条数据。</p><p>但现实世界是不确定的，各种性能损耗、网络延迟都会影响数据达到的顺序，比如在时间上先发生的事件反而最后到达。</p><p>这就导致<a href="https://flink.apache.org/" target="_blank" rel="noopener noreferrer">Flink</a>为了保持事件时间的自然顺序，而不得不中断处理进程，等待后续数据的到达，影响程序性能。</p><h3 id="摄入时间-ingestion-time" tabindex="-1"><a class="header-anchor" href="#摄入时间-ingestion-time"><span>摄入时间（Ingestion Time）</span></a></h3><p>这个时间语义用途不大，和前两者相比，它的作用几乎可以忽略不计。</p><h2 id="watermark" tabindex="-1"><a class="header-anchor" href="#watermark"><span>Watermark</span></a></h2><p>为了处理好<code>事件时间（Event Time）</code>的带来的影响，<a href="https://flink.apache.org/" target="_blank" rel="noopener noreferrer">Flink</a>采用了一种称为<code>Watermark（水印）</code>的机制。</p><p>所谓<code>Watermark（水印）</code>，本质上是一个逻辑时钟，用来 <strong><mark>衡量事件时间进度的机制，它让<code>Flink</code>等待指定的时间，当满足<code>水位线</code>要求后立即进行计算</mark></strong>。</p><p>解释一下这句话。</p><p>例如，现在需要让<a href="https://flink.apache.org/" target="_blank" rel="noopener noreferrer">Flink</a>统计从<code>10:00</code>开始的10分钟内的登录用户数。</p><ul><li>理想情况下，用户登录的时间有先有后，数据进入到<a href="https://flink.apache.org/" target="_blank" rel="noopener noreferrer">Flink</a>中也是完全有序的，就像这样。</li></ul><figure><img src="https://tianmazuo.com/technology/bigdata/flink/flink-05.png" alt="理想情况下的数据次序" tabindex="0" loading="lazy"><figcaption>理想情况下的数据次序</figcaption></figure><ul><li>但实际上，虽然用户登录的时间有先有后，由于各种网络延迟、上游系统宕机、系统运行缓慢等因素，让有些数据<code>晚点</code>抵达。例如，<code>10:01</code>的数据抵达<code>Flink</code>的时间比<code>10:02</code>的更晚。</li></ul><figure><img src="https://tianmazuo.com/technology/bigdata/flink/flink-06.png" alt="数据：的数据比的数据要更晚抵达" tabindex="0" loading="lazy"><figcaption>数据<code>晚点</code>：<code>10:01</code>的数据比<code>10:02</code>的数据要更晚抵达</figcaption></figure><p>这也还算正常，毕竟它还在10分钟的统计范围内。</p><ul><li>但是有的数据就晚得有点离谱了，过了10分钟之后竟然还没有到。比如，<code>10:11</code>之后，<code>10:08</code>的数据才姗姗来迟。更离谱的是它后面竟然不是<code>10:12</code>的数据，而是<code>10:07</code>的数据。</li></ul><figure><img src="https://tianmazuo.com/technology/bigdata/flink/flink-07.png" alt="姗姗来迟的数据" tabindex="0" loading="lazy"><figcaption>姗姗来迟的数据</figcaption></figure><ul><li><p>所以，现在面临三种选择。</p><ul><li><p>一是直接丢弃掉这些已经错过发车时间的数据。</p></li><li><p>二是为了数据尽可能地完整，无限期地等下去。</p></li><li><p>三是给出最后通牒：再等2分钟，如果还不来就直接发车。</p></li></ul></li><li><p>这三种不同的等待延迟数据的处理机制，就称为<a href="https://nightlies.apache.org/flink/flink-docs-master/docs/concepts/time/#event-time-and-watermarks" target="_blank" rel="noopener noreferrer">Watermark水印</a></p></li></ul><figure><img src="https://tianmazuo.com/technology/bigdata/flink/flink-08.png" alt="Watermark水印机制" tabindex="0" loading="lazy"><figcaption>Watermark水印机制</figcaption></figure><p>所以，再重复一下前面的话：<a href="https://nightlies.apache.org/flink/flink-docs-master/docs/concepts/time/#event-time-and-watermarks" target="_blank" rel="noopener noreferrer">Watermark水印</a>本质上就是一种 <strong><mark>衡量事件时间进度的机制，它让<code>Flink</code>等待指定的时间，当满足<code>水位线</code>要求后立即进行计算</mark></strong>。</p><p>可以这么理解<code>Watermark水印</code>和<a href="https://flink.apache.org/" target="_blank" rel="noopener noreferrer">Flink</a>触发机制的关系。</p><ul><li><p><strong><mark>水位线 = 进入Flink的最大事件时间 ‒ 最大延迟时间</mark></strong>。</p></li><li><p><strong><mark>水位线 &gt;= 窗口结束时间，立即触发计算（发车）</mark></strong>。</p></li></ul><p>在上面的<code>Watermark水印机制</code>图中。</p><ul><li><p><code>进入Flink的最大事件时间</code>：<code>10:12</code>（它并不一定是最后一个进入<code>Flink</code>的，但一定是最大的）。</p></li><li><p><code>最大延迟时间</code>：2分钟。</p></li><li><p><code>窗口结束时间</code>：<code>10:10</code>。</p></li><li><p><code>触发条件</code>：水位线（<code>10:12</code> - <code>10:10</code>） &gt;= <code>2分钟</code>。</p></li><li><p><code>丢弃数据</code>：即使后面还有<code>10:03</code>的迟到数据，<code>Flink</code>也不等了，<strong><mark>如果窗口内有数据</mark></strong> 则立即触发计算任务。</p></li></ul><p>下面的两张图是官方给出的对于<a href="https://nightlies.apache.org/flink/flink-docs-master/docs/concepts/time/#event-time-and-watermarks" target="_blank" rel="noopener noreferrer">Watermark水印</a>机制的解释。</p><figure><img src="https://tianmazuo.com/technology/bigdata/flink/flink-09.png" alt="有序流和乱序流的水印" tabindex="0" loading="lazy"><figcaption>有序流和乱序流的水印</figcaption></figure><figure><img src="https://tianmazuo.com/technology/bigdata/flink/flink-10.png" alt="并行流的水印" tabindex="0" loading="lazy"><figcaption>并行流的水印</figcaption></figure><p>但实话说，它们并没有很清楚很完整地表达出<a href="https://nightlies.apache.org/flink/flink-docs-master/docs/concepts/time/#event-time-and-watermarks" target="_blank" rel="noopener noreferrer">Watermark水印</a>意思。</p>`,45),l=[t];function r(p,o){return a(),e("div",null,l)}const c=i(s,[["render",r],["__file","time.html.vue"]]),d=JSON.parse('{"path":"/technology/bigdata/flink/time.html","title":"Time时间机制与Watermark","lang":"zh-CN","frontmatter":{"title":"Time时间机制与Watermark","icon":"warehouse","category":["大数据","Flink"],"tag":["大数据","Flink","Time","Watermark"],"date":"2023-05-09T00:00:00.000Z","isOriginal":true,"star":true,"description":"Flink中的时间语义 在现实世界中，数据不可能会像理想中的那样，来一条就处理一条，反而是各种网络故障、数据延迟、乱序等问题更多更常态化一些。 为了更精准地处理数据流，Flink定义了三种不同的时间语义（时间在Flink流处理中的意义）。 处理时间（Processing Time）：是执行Flink计算的机器的系统时间，可能是某台独立部署的机器，也可能...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/technology/bigdata/flink/time.html"}],["meta",{"property":"og:site_name","content":"添码座"}],["meta",{"property":"og:title","content":"Time时间机制与Watermark"}],["meta",{"property":"og:description","content":"Flink中的时间语义 在现实世界中，数据不可能会像理想中的那样，来一条就处理一条，反而是各种网络故障、数据延迟、乱序等问题更多更常态化一些。 为了更精准地处理数据流，Flink定义了三种不同的时间语义（时间在Flink流处理中的意义）。 处理时间（Processing Time）：是执行Flink计算的机器的系统时间，可能是某台独立部署的机器，也可能..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://tianmazuo.com/technology/bigdata/flink/flink-04.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"添码座"}],["meta",{"property":"article:tag","content":"大数据"}],["meta",{"property":"article:tag","content":"Flink"}],["meta",{"property":"article:tag","content":"Time"}],["meta",{"property":"article:tag","content":"Watermark"}],["meta",{"property":"article:published_time","content":"2023-05-09T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Time时间机制与Watermark\\",\\"image\\":[\\"https://tianmazuo.com/technology/bigdata/flink/flink-04.png\\",\\"https://tianmazuo.com/technology/bigdata/flink/flink-05.png\\",\\"https://tianmazuo.com/technology/bigdata/flink/flink-06.png\\",\\"https://tianmazuo.com/technology/bigdata/flink/flink-07.png\\",\\"https://tianmazuo.com/technology/bigdata/flink/flink-08.png\\",\\"https://tianmazuo.com/technology/bigdata/flink/flink-09.png\\",\\"https://tianmazuo.com/technology/bigdata/flink/flink-10.png\\"],\\"datePublished\\":\\"2023-05-09T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"添码座\\",\\"url\\":\\"https://www.tianmazuo.com/about/\\"}]}"]]},"headers":[{"level":2,"title":"Flink中的时间语义","slug":"flink中的时间语义","link":"#flink中的时间语义","children":[{"level":3,"title":"处理时间（Processing Time）","slug":"处理时间-processing-time","link":"#处理时间-processing-time","children":[]},{"level":3,"title":"事件时间（Event Time）","slug":"事件时间-event-time","link":"#事件时间-event-time","children":[]},{"level":3,"title":"摄入时间（Ingestion Time）","slug":"摄入时间-ingestion-time","link":"#摄入时间-ingestion-time","children":[]}]},{"level":2,"title":"Watermark","slug":"watermark","link":"#watermark","children":[]}],"git":{},"readingTime":{"minutes":6.11,"words":1832},"filePathRelative":"technology/bigdata/flink/time.md","localizedDate":"2023年5月9日","excerpt":"<h2>Flink中的时间语义</h2>\\n<p>在现实世界中，数据不可能会像理想中的那样，来一条就处理一条，反而是各种网络故障、数据延迟、乱序等问题更多更常态化一些。</p>\\n<p>为了更精准地处理数据流，<a href=\\"https://flink.apache.org/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Flink</a>定义了三种不同的时间语义（<a href=\\"https://nightlies.apache.org/flink/flink-docs-master/docs/concepts/time/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">时间在Flink流处理中的意义</a>）。</p>","autoDesc":true}');export{c as comp,d as data};
