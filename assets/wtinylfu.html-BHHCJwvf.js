import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,o as n,d as l}from"./app-CiwSPZKD.js";const d={},r=l('<h2 id="淘汰算法" tabindex="-1"><a class="header-anchor" href="#淘汰算法"><span>淘汰算法</span></a></h2><p>相对于动辄按<code>TB</code>计的硬盘来说，内存要小得多，而且贵得多，所以不能把所有的数据全都放到内存，而只能够在内存中临时保存更加有价值的数据。</p><p>查询一个数据，如果这个数据刚好在内存的缓存里，就称之为缓存<code>命中</code>。因此，<a href="https://baike.baidu.com/item/%E7%BC%93%E5%AD%98%E5%91%BD%E4%B8%AD%E7%8E%87" target="_blank" rel="noopener noreferrer">缓存命中率</a>就是衡量一个缓存好坏的重要指标。</p><p>因为内存装不下那么多的数据，而且有些数据过段时间可能就没用了，所以需要定期清理，淘汰掉一些没用的或过期的数据，这就是<code>缓存淘汰算法</code>。</p><p>常见的淘汰算法包括如下几种。</p><ul><li><p><code>FIFO</code>：全称<code>First In First Out</code>，先进先出算法，就是谁先来就淘汰谁，众生平等，只能顺序读写。这是最早使用的淘汰算法，问题在于如果某些数据经常使用，也会被淘汰掉。</p><p><code>FIFO</code>的执行过程用下面的表就能说明。</p><table><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">4</th><th style="text-align:center;">3</th><th style="text-align:center;">2</th><th style="text-align:center;">1</th></tr></thead><tbody><tr><td style="text-align:center;">依次插入123</td><td style="text-align:center;"></td><td style="text-align:center;">3</td><td style="text-align:center;">2</td><td style="text-align:center;">1</td></tr><tr><td style="text-align:center;">插入4</td><td style="text-align:center;">4</td><td style="text-align:center;">3</td><td style="text-align:center;">2</td><td style="text-align:center;">1</td></tr><tr><td style="text-align:center;">插入5</td><td style="text-align:center;">5</td><td style="text-align:center;">4</td><td style="text-align:center;">3</td><td style="text-align:center;">2</td></tr></tbody></table></li><li><p><code>LRU</code>：全称<code>Least Recently Used</code>，最近最少使用算法，就是谁用得最少就淘汰谁，这是目前主流的缓存淘汰算法。问题在于，如果某些数据隔一段时间就会被频繁使用，也会被淘汰掉。</p><p><code>LRU</code>的执行过程用下面的表就能说明。</p><table><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">4</th><th style="text-align:center;">3</th><th style="text-align:center;">2</th><th style="text-align:center;">1</th></tr></thead><tbody><tr><td style="text-align:center;">依次插入123</td><td style="text-align:center;"></td><td style="text-align:center;">3</td><td style="text-align:center;">2</td><td style="text-align:center;">1</td></tr><tr><td style="text-align:center;">插入4</td><td style="text-align:center;">4</td><td style="text-align:center;">3</td><td style="text-align:center;">2</td><td style="text-align:center;">1</td></tr><tr><td style="text-align:center;">插入5，1被淘汰</td><td style="text-align:center;">5</td><td style="text-align:center;">4</td><td style="text-align:center;">3</td><td style="text-align:center;">2</td></tr><tr><td style="text-align:center;">插入2，更新3的位置</td><td style="text-align:center;">5</td><td style="text-align:center;">4</td><td style="text-align:center;">2</td><td style="text-align:center;">3</td></tr><tr><td style="text-align:center;">插入6，2被淘汰</td><td style="text-align:center;">6</td><td style="text-align:center;">5</td><td style="text-align:center;">4</td><td style="text-align:center;">3</td></tr></tbody></table></li><li><p><code>LFU</code>：全称<code>Least Frequently Used</code>，最近不经常使用算法，就是淘汰最近用得最少的那些数据，这是对<code>LRU</code>的一种改进。但同样也有问题，就是某个数据如果只是一开始出现的很频繁，但后面再也没出现过，那么仍然可能被缓存着。</p><p><code>LFU</code>的执行过程用下面的表就能说明。</p><table><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">4</th><th style="text-align:center;">3</th><th style="text-align:center;">2</th><th style="text-align:center;">1</th></tr></thead><tbody><tr><td style="text-align:center;">依次插入123</td><td style="text-align:center;"></td><td style="text-align:center;">3(1)</td><td style="text-align:center;">2(1)</td><td style="text-align:center;">1(1)</td></tr><tr><td style="text-align:center;">插入4</td><td style="text-align:center;">4(1)</td><td style="text-align:center;">3(1)</td><td style="text-align:center;">2(1)</td><td style="text-align:center;">1(1)</td></tr><tr><td style="text-align:center;">再次插入124</td><td style="text-align:center;">4(2)</td><td style="text-align:center;">3(1)</td><td style="text-align:center;">2(2)</td><td style="text-align:center;">1(2)</td></tr><tr><td style="text-align:center;">插入5，3被淘汰</td><td style="text-align:center;">5(1)</td><td style="text-align:center;">4(2)</td><td style="text-align:center;">2(2)</td><td style="text-align:center;">1(2)</td></tr><tr><td style="text-align:center;">插入1</td><td style="text-align:center;">5(1)</td><td style="text-align:center;">4(2)</td><td style="text-align:center;">2(2)</td><td style="text-align:center;">1(3)</td></tr><tr><td style="text-align:center;">插入2</td><td style="text-align:center;">5(1)</td><td style="text-align:center;">4(2)</td><td style="text-align:center;">2(3)</td><td style="text-align:center;">1(3)</td></tr><tr><td style="text-align:center;">插入2</td><td style="text-align:center;">5(1)</td><td style="text-align:center;">4(2)</td><td style="text-align:center;">2(4)</td><td style="text-align:center;">1(3)</td></tr></tbody></table></li></ul><p>因此，<code>LFU</code>两个很明显的缺点。</p><ul><li><p>需要维护大而复杂的元数据来实现算法，而且每次访问以后都需要更新，开销巨大。</p></li><li><p>如果访问频率变化，<code>LFU</code>的频率信息却没有随之变化，就会造成<code>命中率</code>急剧下降。</p></li></ul><br><h2 id="tinylfu" tabindex="-1"><a class="header-anchor" href="#tinylfu"><span>TinyLFU</span></a></h2><p><a href="https://arxiv.org/abs/1512.00727" target="_blank" rel="noopener noreferrer">TinyLFU</a>利用<a href="https://en.wikipedia.org/wiki/Count-min_sketch" target="_blank" rel="noopener noreferrer">Count-Min Sketch</a>算法维护近期访问数据的频率信息，可以在具有较大访问量的场景下近似的替代<code>LFU</code>的数据统计部分，其原理有些类似<a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="noopener noreferrer">Bloom Filter（布隆过滤器）</a>。</p><p><a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="noopener noreferrer">Bloom Filter</a>是一种空间利用效率很高的随机数据结构，它能用bit数组很简洁地表示一个集合。</p><ul><li><p>使用一个大的<code>bit</code>数组存储所有<code>key</code>，每一个<code>key</code>通过多次不同的<code>Hash</code>计算映射到数组的不同<code>bit</code>位。</p></li><li><p>如果<code>key</code>存在就将对应的<code>bit</code>位加1，这样就可以通过少量的存储空间进行大量的数据过滤。</p></li><li><p><a href="https://arxiv.org/abs/1512.00727" target="_blank" rel="noopener noreferrer">TinyLFU</a>把多个<code>bit</code>位看做一个整体，用来统计<code>key</code>的使用频率。在读取时，取映射的所有值中的最小的值作为<code>key</code>的使用频率。</p></li></ul><p>比如针对<code>key</code>的<code>Hash</code>计算结果会映射到下面的<code>bit</code>数组中。</p><figure><img src="https://tianmazuo.com/technology/sundry/caffeine/caffeine-02.png" alt="TinyLFU" tabindex="0" loading="lazy"><figcaption>TinyLFU</figcaption></figure><ul><li><p><a href="https://arxiv.org/abs/1512.00727" target="_blank" rel="noopener noreferrer">TinyLFU</a>会读取数值最小的h2(a)作为<code>key</code>的使用频率数据。</p></li><li><p><a href="https://github.com/ben-manes/caffeine" target="_blank" rel="noopener noreferrer">Caffeine</a>中维护了一个4位的<a href="https://en.wikipedia.org/wiki/Count-min_sketch" target="_blank" rel="noopener noreferrer">Count-Min Sketch</a>用来记录<code>key</code>的使用频率，这也意味着统计的<code>key</code>最大使用频率为15。</p></li></ul><br><h2 id="w-tinylfu" tabindex="-1"><a class="header-anchor" href="#w-tinylfu"><span>W-TinyLFU</span></a></h2><p><a href="https://arxiv.org/abs/1512.00727" target="_blank" rel="noopener noreferrer">TinyLFU</a>仍然有<code>LFU</code>的第二个问题：如果访问频率突变，会造成缓存命中率的急剧下降。</p><p>例如，微博热点事件，某些词当天被搜索10W次，但是热度过去了，可能就再也不会出现了，然而相关数据却依然还在缓存中没被清理。</p><p><code>W-TinyLFU</code>正是为了解决这类数据过期问题而诞生，它由两部分组成。</p><ul><li><p>窗口缓存<code>Window Cache</code>使用没有任何回收策略的<code>LRU</code>，占总缓存大小的<code>1%</code>，用于存储新到来的数据，主要为应对短期流量突发的访问场景。</p></li><li><p>主缓存<code>Main Cache</code>使用<code>分段SLRU</code> + <a href="https://arxiv.org/abs/1512.00727" target="_blank" rel="noopener noreferrer">TinyLFU</a>，占总缓存大小的<code>99%</code>。</p></li><li><p>其中<code>SLRU</code>又被分为两个区。</p><ul><li><p><code>Probation</code>区，用于存储比较冷门的数据，占用主缓存20%空间。</p></li><li><p><code>Protected</code>区，用于存储比较热门的数据，占用主缓存80%空间。</p></li></ul></li><li><p>新添加的数据首先放入窗口缓存<code>Window Cache（LRU）</code>中，同时由<a href="https://arxiv.org/abs/1512.00727" target="_blank" rel="noopener noreferrer">TinyLFU</a>完成计数。</p></li><li><p>如果<code>Window Cache</code>满了，就把<code>Window Cache</code>淘汰的数据转移到主缓存<code>Probation</code>区中。</p></li><li><p>如果<code>Probation</code>区还未满，并且其中的数据在后续操作中再次被访问时，那么该条数据会进入<code>Protected</code>区。</p></li><li><p>如果<code>Probation</code>区也满了，就比较从窗口缓存<code>Window Cache</code>转移过来的数据（候选者）和<code>Probation</code>要淘汰的数据（受害者）。</p><ul><li><p>首先获取<a href="https://arxiv.org/abs/1512.00727" target="_blank" rel="noopener noreferrer">TinyLFU</a>中记录的候选人和受害者的频率。</p></li><li><p>如果候选者频率 &gt; 受害者频率，则淘汰受害者。</p></li><li><p>如果候选者频率 &lt;= 5，则淘汰候选者。</p></li><li><p>其余情况随机处理。</p></li></ul></li><li><p>如果<code>Protected</code>区也满了，那么会按照<code>LRU</code>策略将数据驱逐到<code>Probation</code>区</p></li></ul><figure><img src="https://tianmazuo.com/technology/sundry/caffeine/caffeine-03.png" alt="W-TinyLFU" tabindex="0" loading="lazy"><figcaption>W-TinyLFU</figcaption></figure><p>其实<code>W-TinyLFU</code>算法的淘汰过程和<a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" target="_blank" rel="noopener noreferrer">JVM GC</a>过程非常像。</p><ul><li><p>在区域划分上</p><ul><li><p><code>Window Cache</code>对应<code>S0</code>和<code>S1</code>。</p></li><li><p><code>Probation</code>区对应<code>Eden</code>区。</p></li><li><p><code>Protected</code>区对应老年代。</p></li></ul></li><li><p>在数据淘汰流程上</p><ul><li><p>先进入<code>Window Cache</code>（<code>S0</code>和<code>S1</code>）。</p></li><li><p>再进入<code>Probation</code>区（<code>Eden</code>区）或从<code>Probation</code>区淘汰。</p></li><li><p>再进入<code>Protected</code>区（老年代）或从<code>Protected</code>区淘汰。</p></li></ul></li></ul>',25),o=[r];function i(c,a){return n(),t("div",null,o)}const y=e(d,[["render",i],["__file","wtinylfu.html.vue"]]),g=JSON.parse('{"path":"/technology/sundry/caffeine/wtinylfu.html","title":"W-TinyLFU淘汰算法","lang":"zh-CN","frontmatter":{"title":"W-TinyLFU淘汰算法","icon":"flask-vial","category":["杂项","Caffeine"],"tag":["杂项","Caffeine"],"date":"2021-10-21T00:00:00.000Z","isOriginal":true,"star":true,"description":"淘汰算法 相对于动辄按TB计的硬盘来说，内存要小得多，而且贵得多，所以不能把所有的数据全都放到内存，而只能够在内存中临时保存更加有价值的数据。 查询一个数据，如果这个数据刚好在内存的缓存里，就称之为缓存命中。因此，缓存命中率就是衡量一个缓存好坏的重要指标。 因为内存装不下那么多的数据，而且有些数据过段时间可能就没用了，所以需要定期清理，淘汰掉一些没用的...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/technology/sundry/caffeine/wtinylfu.html"}],["meta",{"property":"og:site_name","content":"添码座"}],["meta",{"property":"og:title","content":"W-TinyLFU淘汰算法"}],["meta",{"property":"og:description","content":"淘汰算法 相对于动辄按TB计的硬盘来说，内存要小得多，而且贵得多，所以不能把所有的数据全都放到内存，而只能够在内存中临时保存更加有价值的数据。 查询一个数据，如果这个数据刚好在内存的缓存里，就称之为缓存命中。因此，缓存命中率就是衡量一个缓存好坏的重要指标。 因为内存装不下那么多的数据，而且有些数据过段时间可能就没用了，所以需要定期清理，淘汰掉一些没用的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://tianmazuo.com/technology/sundry/caffeine/caffeine-02.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"添码座"}],["meta",{"property":"article:tag","content":"杂项"}],["meta",{"property":"article:tag","content":"Caffeine"}],["meta",{"property":"article:published_time","content":"2021-10-21T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"W-TinyLFU淘汰算法\\",\\"image\\":[\\"https://tianmazuo.com/technology/sundry/caffeine/caffeine-02.png\\",\\"https://tianmazuo.com/technology/sundry/caffeine/caffeine-03.png\\"],\\"datePublished\\":\\"2021-10-21T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"添码座\\",\\"url\\":\\"https://www.tianmazuo.com/about/\\"}]}"]]},"headers":[{"level":2,"title":"淘汰算法","slug":"淘汰算法","link":"#淘汰算法","children":[]},{"level":2,"title":"TinyLFU","slug":"tinylfu","link":"#tinylfu","children":[]},{"level":2,"title":"W-TinyLFU","slug":"w-tinylfu","link":"#w-tinylfu","children":[]}],"git":{},"readingTime":{"minutes":5.33,"words":1598},"filePathRelative":"technology/sundry/caffeine/wtinylfu.md","localizedDate":"2021年10月21日","excerpt":"<h2>淘汰算法</h2>\\n<p>相对于动辄按<code>TB</code>计的硬盘来说，内存要小得多，而且贵得多，所以不能把所有的数据全都放到内存，而只能够在内存中临时保存更加有价值的数据。</p>\\n<p>查询一个数据，如果这个数据刚好在内存的缓存里，就称之为缓存<code>命中</code>。因此，<a href=\\"https://baike.baidu.com/item/%E7%BC%93%E5%AD%98%E5%91%BD%E4%B8%AD%E7%8E%87\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">缓存命中率</a>就是衡量一个缓存好坏的重要指标。</p>","autoDesc":true}');export{y as comp,g as data};
