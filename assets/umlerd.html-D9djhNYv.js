import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,o as n,d as i}from"./app-B5m7CcSj.js";const c={},s=i(`<h2 id="uml" tabindex="-1"><a class="header-anchor" href="#uml"><span>UML</span></a></h2><p><code>UML</code>是<code>Unified Modeling Language</code>的英文缩写，中文名称为<code>统一建模语言</code>。它是一套图形化的符号语义系统，可以说是<code>RUP</code>的“副产品”。但有意思的是，它的名气好像比<code>RUP</code>还大，而且<code>RUP</code>虽然已经逐渐没落了，但它却经久不衰。</p><p><code>UML</code>诞生的时间，正是<code>面向对象的软件设计（Object-Oriented Design，OOD）</code>方法论逐步迈向<code>C位</code>的时代。彼时，各种编程语言、设计思想、开发流程、管理方法如雨后春笋般纷纷冒头，给实际的软件开发工作造成了很大的困扰，工程师们<code>语言不通</code>、<code>思想不统一</code>、<code>流程不一致</code>，导致交流想法异常困难。</p><p>而<code>UML</code>通过一套图形标志来同意这种差异。例如，当使用不同编程语言进行开发的工程师们讨论<code>类</code>的时候，他们可以用<code>UML</code>的<code>类图</code>画出心中所想，然后告诉其他人：这就是我要表达的<code>类</code>。而懂<code>UML</code>工程师看到<code>类图</code>就能马上明白：哦，原来TA说的是这个意思。</p><p><code>UML</code>在软件开发领域中的作用，就如同建筑设计图在工程领域中的作用。</p><p><code>UML</code>包括三大类设计图。</p><ul><li><p><code>结构图</code>，用于描述系统的静态结构，包括<code>类图（Class Diagram）</code>、<code>对象图（Object Diagram）</code>、<code>组件图（Component Diagram）</code>和<code>部署图（Deployment Diagram）</code>。</p></li><li><p><code>行为图</code>，用于描述系统的动态行为，包括<code>用例图（Use Case Diagram）</code>、<code>活动图（Activity Diagram，也叫流程图）</code>、<code>状态图（State Diagram）</code>、<code>时序图（Sequence Diagram）</code>和<code>通信图（Communication Diagram）</code>。</p></li><li><p><code>交互图</code>，描述系统中对象之间的交互关系，包括<code>时序图（Sequence Diagram）</code>和<code>协作图（Collaboration Diagram）</code>。</p></li></ul><p>如果按软件项目的开发阶段来划分，出现频率最高的几种分别是<code>用例图</code>、<code>类或对象图</code>、<code>流程图</code>、<code>状态图</code>和<code>时序图</code>。</p><figure><img src="https://tianmazuo.com/technology/engineering/process/process-14.png" alt="UML图形种类划分" tabindex="0" loading="lazy"><figcaption>UML图形种类划分</figcaption></figure><h3 id="用例图" tabindex="-1"><a class="header-anchor" href="#用例图"><span>用例图</span></a></h3><p>可以画图的工具很多，但能完整遵循标准<code>UML</code>语法的工具很少。我自己经常使用的只有<a href="https://www.ibm.com/support/pages/node/306477?mhsrc=ibmsearch_a&amp;mhq=rational%20rose" target="_blank" rel="noopener noreferrer">Rational Rose</a>（目前已经不可用）和<a href="https://staruml.io/" target="_blank" rel="noopener noreferrer">StarUML</a>。</p><p><a href="https://staruml.io/" target="_blank" rel="noopener noreferrer">StarUML</a>很好地继承了<a href="https://www.ibm.com/support/pages/node/306477?mhsrc=ibmsearch_a&amp;mhq=rational%20rose" target="_blank" rel="noopener noreferrer">Rational Rose</a>的大部分功能，风格上也是一脉相承，而且至今仍在更新。</p><figure><img src="https://tianmazuo.com/technology/engineering/process/process-15.png" alt="StarUML的类图" tabindex="0" loading="lazy"><figcaption>StarUML的类图</figcaption></figure><p>可以把<code>用例（Use Case）</code>理解为一个独立且完整的功能需求，它用来描述用户、系统、需求这三者之间的关联关系。</p><p>通过用例，开发工程师可以清楚地知道下面的信息。</p><ul><li><p>系统为谁服务？谁是最终用户（而非中间用户）？</p></li><li><p>最终用户希望系统提供什么样的服务？又希望得到什么样的输出？</p></li><li><p>最终用户能为系统提供什么样的输入？有哪些约束条件？</p></li></ul><p>用例图主要有四个组成部分。</p><ul><li><code>参与者（Actor）</code>，它并非指具体的人，而是指的存在于外部并直接与系统交互的人、子系统、其他系统或对象，它在UML中用一个<code>小人</code>表示。</li></ul><figure><img src="https://tianmazuo.com/technology/engineering/process/process-16.png" alt="参与者（Actor）" tabindex="0" loading="lazy"><figcaption>参与者（Actor）</figcaption></figure><ul><li><code>用例（Use Case）</code>，用来描述需要给参与者提供的功能或服务。它必须由参与者来执行，获取参与者的输入，并将输出结果反馈给参与者或系统。</li></ul><figure><img src="https://tianmazuo.com/technology/engineering/process/process-17.png" alt="用例（Use Case）" tabindex="0" loading="lazy"><figcaption>用例（Use Case）</figcaption></figure><ul><li><code>关系（Association）</code>，表示参与者和用例之间的联系，也可以用来表示参与者和参与者、用例和用例之间的关系。有四种关系：<code>关联</code>、<code>包含</code>、<code>扩展</code>和<code>泛化</code>。</li></ul><div style="text-align:center;"><p><img src="https://tianmazuo.com/technology/engineering/process/process-18.png" alt="用例" width="600" height="300" loading="lazy"> <img src="https://tianmazuo.com/technology/engineering/process/process-19.png" alt="用例" width="600" height="200" loading="lazy"></p><p><img src="https://tianmazuo.com/technology/engineering/process/process-20.png" alt="用例" width="600" height="200" loading="lazy"> <img src="https://tianmazuo.com/technology/engineering/process/process-21.png" alt="用例" width="600" height="400" loading="lazy"></p></div><ul><li><code>系统（System）</code>，是用例需要描述的对象，它可以是一个软件平台或者一个硬件设备，或者是一次促销活动，也可以是一个更大的系统的一部分。它有自己的边界，由参与者、用例和关系共同组成。</li></ul><p>另外，在用例文档中切忌啰嗦，一般都是非常简洁的<code>名词 + 动词</code>的形式来描述主要业务流程，至于分支流程和边界条件等详细内容，可以在需求说明书中给出。</p><p>下面是一个良好的用例文档范例。</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">1.用户打开登录界面。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">2.用户输入用户名和密码。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">3.系统确认用户名和密码。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">4.用户登录成功。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">5.......</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而比较啰嗦的反面典型则是这样的。</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">1.用户打开浏览器，然后在浏览器地址栏中输入地址......，浏览器保存Cookie......。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">2.页面显示出登录界面，用户单击页面输入框，然后输入用户名和密码。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">3.输入用户名密码时弹出人机确认对话框，用户确认身份，系统读取用户输入的登录名称和密码。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">4.后台先验证用户名是否存在，核对用户密码是否正确。如果用户存在且密码匹配则用户登录成，否则登录失败，给出页面提示。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">5.......</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="类图" tabindex="-1"><a class="header-anchor" href="#类图"><span>类图</span></a></h3><p><code>用例图</code>描述的是需求的结构及其关系，而<code>类图</code>则反应的是系统中类或对象之间的结构与关联关系。这是一种静态的建模方法，是对现实世界的抽象。</p><p><code>类图</code>分为两大部分，一是类的基本属性，包括类名、类的属性和类的方法。</p><figure><img src="https://tianmazuo.com/technology/engineering/process/process-22.png" alt="类图的基本属性" tabindex="0" loading="lazy"><figcaption>类图的基本属性</figcaption></figure><p><code>类图</code>的另外一部分就是类与类之间的关系。在UML类图中，类之间共有六种关系：<code>关联关系</code>、<code>聚合关系</code>、<code>组合关系</code>、<code>实现关系</code>、<code>泛化关系</code>和<code>依赖关系</code>。</p><figure><img src="https://tianmazuo.com/technology/engineering/process/process-23.png" alt="关联关系" tabindex="0" loading="lazy"><figcaption>关联关系</figcaption></figure><figure><img src="https://tianmazuo.com/technology/engineering/process/process-24.png" alt="聚合关系" tabindex="0" loading="lazy"><figcaption>聚合关系</figcaption></figure><figure><img src="https://tianmazuo.com/technology/engineering/process/process-25.png" alt="组合关系" tabindex="0" loading="lazy"><figcaption>组合关系</figcaption></figure><figure><img src="https://tianmazuo.com/technology/engineering/process/process-26.png" alt="实现关系" tabindex="0" loading="lazy"><figcaption>实现关系</figcaption></figure><figure><img src="https://tianmazuo.com/technology/engineering/process/process-27.png" alt="泛化关系" tabindex="0" loading="lazy"><figcaption>泛化关系</figcaption></figure><figure><img src="https://tianmazuo.com/technology/engineering/process/process-28.png" alt="依赖关系" tabindex="0" loading="lazy"><figcaption>依赖关系</figcaption></figure><h3 id="流程图" tabindex="-1"><a class="header-anchor" href="#流程图"><span>流程图</span></a></h3><p><code>流程图</code>就是将业务流程的各个环节和分支条件按照事件发生的顺序展现出来。</p><p>下面就是典型的用户登录流程图。</p><figure><img src="https://tianmazuo.com/technology/engineering/process/process-29.png" alt="用户登录流程图" tabindex="0" loading="lazy"><figcaption>用户登录流程图</figcaption></figure><p>上面图中有三个竖长的矩形，分别表示<code>用户</code>、<code>后端</code>和\`\`前端<code>，这在流程图中称为</code>泳道\`，就像泳池中的泳道一样，所以流程图有时候也叫“泳道图”。</p><p>当然，没有这些<code>修饰</code>，流程图依然是流程图。</p><figure><img src="https://tianmazuo.com/technology/engineering/process/process-30.png" alt="用户登录流程图" tabindex="0" loading="lazy"><figcaption>用户登录流程图</figcaption></figure><h3 id="状态图" tabindex="-1"><a class="header-anchor" href="#状态图"><span>状态图</span></a></h3><p><code>状态图</code>和<code>流程图</code>非常类似，但它关注的不是业务流程的推进，而是某些业务领域在事件发生时的状态变化，例如订单状态。</p><p>有些<code>UML</code>图中将状态图弄的很复杂，包括诸如组合状态、历史状态、状态机等概念，但大多数情况下都用不到它们。</p><figure><img src="https://tianmazuo.com/technology/engineering/process/process-31.png" alt="典型的状态图" tabindex="0" loading="lazy"><figcaption>典型的状态图</figcaption></figure><ul><li><p>当状态A经过事件1时，如果符合条件A，就转换到状态B，否则就转换到状态C。</p></li><li><p>状态C可以通过条件B完成自身状态的不断循环检查，例如已创建的订单如果未付款，那么它是否还在付款超时时间之内等这样的循环检查条件。</p></li><li><p>只有当状态B和状态C同时满足业务约束A时，业务才能继续转换到状态D并进而完成。</p></li></ul><p>以终端用户视角的订单履约状态为例，其状态图会像下面这样。</p><figure><img src="https://tianmazuo.com/technology/engineering/process/process-32.png" alt="订单履约状态图" tabindex="0" loading="lazy"><figcaption>订单履约状态图</figcaption></figure><h3 id="时序图" tabindex="-1"><a class="header-anchor" href="#时序图"><span>时序图</span></a></h3><p><code>时序图</code>又被称为<code>序列图（Sequence Diagram）</code>，它通过对象之间互相调用方法以及发送消息的时间顺序，来显示多个对象之间的动态协作过程。</p><p><code>时序图</code>将<code>类图</code>和<code>流程图</code>结合到了一起，它既有对象的方法调用，也有调用时的流程事件。相对于其他<code>UML</code>图，<code>时序图</code>更强调交互的时间顺序，同时也能很直观地描述并发过程。时序图的组成部分也比较多，但和状态图一样，真正需要用到的并不多。一个最简单的<code>时序图</code>一定会包括这四类组件：<code>对象</code>、<code>生命线</code>、<code>关联消息</code>和<code>控制焦点</code>。</p><p>下面是OAuth 2.0第三方授权登录时序图。</p><figure><img src="https://tianmazuo.com/technology/engineering/process/process-33.png" alt="OAuth 2.0第三方授权登录时序图" tabindex="0" loading="lazy"><figcaption>OAuth 2.0第三方授权登录时序图</figcaption></figure><p>搞清楚了<code>时序图</code>的结构后，就不难用它来画出与业务相关的对象之间的调用过程了。</p><figure><img src="https://tianmazuo.com/technology/engineering/process/process-34.png" alt="用户在电商网站购物的时序图" tabindex="0" loading="lazy"><figcaption>用户在电商网站购物的时序图</figcaption></figure><br><h2 id="erd" tabindex="-1"><a class="header-anchor" href="#erd"><span>ERD</span></a></h2><p>如果说<code>UML</code>图是用来图形来表示业务系统的结构的话，那么ERD就是一种特殊的<code>UML</code>图，它表示的是业务数据库的各种数据表的结构及其之间的关系。</p><p><code>ERD</code>是英文<code>Entity-Relationship Diagram</code>的翻译，称为<code>实体-关系图</code>，主要用于表示<code>数据实体Entity</code>（通常对应于数据表）、<code>属性Attribute</code>（通常对应于数据表中的字段）和<code>实体之间的关系Relationship</code>（即数据表之间的关联），它是数据库设计中最为常用的工具，没有之一。</p><p>通过<code>ERD</code>，可以清晰地展示出数据模型中各个实体之间的关系，有助于数据库设计人员理解需求和设计出合理的数据（库）模型。</p><p><code>ERD</code>从概念上分为<code>逻辑模型</code>与<code>物理模型</code>，这两类模型其实本质上是同一个，只是详细程度不同。</p><ul><li><code>逻辑模型</code>描述了数据之间的逻辑关系，它独立于具体的数据库管理系统DBMS或存储结构，更侧重于抽象的逻辑概念，而不涉及具体的物理存储细节。</li></ul><figure><img src="https://tianmazuo.com/technology/engineering/process/process-35.png" alt="ERD逻辑模型" tabindex="0" loading="lazy"><figcaption>ERD逻辑模型</figcaption></figure><ul><li><code>物理模型</code>除了添加了更详细的字段属性之外，它和<code>逻辑模型</code>基本没什么区别，而且从模型设计图的外观上也看不出什么不同。可能唯一的区别在于有些<code>ERD</code>软件可以直接从物理模型生成初始化数据库的<code>SQL</code>语句吧，例如<code>PowerDesigner</code>。</li></ul><figure><img src="https://tianmazuo.com/technology/engineering/process/process-36.png" alt="ERD物理模型" tabindex="0" loading="lazy"><figcaption>ERD物理模型</figcaption></figure><p>在<code>ERD</code>中，不同的<code>数据实体Entity</code>之间有六种关系。</p><ul><li><p><code>None</code>，表示一个实体与任何其他的实体之间都没有关系，属于是孤零零的存在，这种情况多见于一些配置表、系统初始化表等之类的特殊实体。</p></li><li><p><code>One and Only One</code>，表示一个实体有且仅有一个对应的实体，如果另一个实体也是这种关系，那这两个实体之间就是基本的<code>一对一映射关系</code>（1 : 1）。例如，每个自然人有且仅有一个对应的身份证，反过来也一样，那么它们之间就是一对一的关系。</p></li></ul><figure><img src="https://tianmazuo.com/technology/engineering/process/process-37.png" alt="“One and Only On”的映射关系" tabindex="0" loading="lazy"><figcaption>“One and Only On”的映射关系</figcaption></figure><ul><li><code>Zero or One</code>，这是<code>一对一映射关系</code>的一个特例，表示一个实体要么没有对应的实体，要么最多只有一个对应的实体。例如，自然人和身份证之间的关系，每个人刚出生的头几年之内都可以没有身份证，但之后最多只能有一个身份证。</li></ul><figure><img src="https://tianmazuo.com/technology/engineering/process/process-38.png" alt="“Zero or One”的映射关系" tabindex="0" loading="lazy"><figcaption>“Zero or One”的映射关系</figcaption></figure><ul><li><code>Many</code>，表示一个实体有多个其他对应的实体，这种关系称为<code>一对多映射关系</code>（1 : n），例如，班级和学生之间就是这种一对多的关系。如果另一个实体也是这种关系，那这两个实体之间就是基本的<code>多对多映射关系</code>（m : n）。例如，学生和课程之间的关系就是多对多的关系。</li></ul><figure><img src="https://tianmazuo.com/technology/engineering/process/process-39.png" alt="“Many”的映射关系" tabindex="0" loading="lazy"><figcaption>“Many”的映射关系</figcaption></figure><ul><li><code>One or Many</code>，这是<code>多对多映射关系</code>的一种特例，表示每个实体至少有另一个对应的实体，或者有多个对应的实体。例如，一本书至少有一个作者，也可以是多为作者联合编写（但书是不可能没有任何作者而能独立存在的）。</li></ul><figure><img src="https://tianmazuo.com/technology/engineering/process/process-40.png" alt="“One or Many”的映射关系" tabindex="0" loading="lazy"><figcaption>“One or Many”的映射关系</figcaption></figure><ul><li><code>Zero or Many</code>，这是<code>多对多映射关系</code>的另一个特例，表示每个实体要么没有另一个对应的实体，要么有多个对应的实体。例如，用户和聊天群之间就属于这种关系。某个用户可以不加入任何聊天群，也可以在多个聊天群中。</li></ul><figure><img src="https://tianmazuo.com/technology/engineering/process/process-41.png" alt="“Zero or Many”的映射关系" tabindex="0" loading="lazy"><figcaption>“Zero or Many”的映射关系</figcaption></figure><p>需要特别注意的是，大多数数据库表之间的关系都是双向的，而且并不是说一张表对另一张表的关系反过来也成立。</p><p>例如，当数据表A为左表，而数据表B为右表时，它们之间是<code>“Zero or One”的映射关系</code>，但是反过来，当数据表B为左表，而数据表A为右表时，它们之间就可能是另外一种映射关系了。</p><p>有一个非常典型的例子。</p><ul><li><p>对用户来说，TA可以不加入任何聊天群，也可以属于一个或多个聊天群，是典型的<code>Zero or Many</code>的映射关系。</p></li><li><p>对聊天群来说，它至少要有一个用户，也可以有多个用户，是典型的<code>One or Many</code>的映射关系。</p></li></ul><p>这一点是每个有经验的开发工程师或者数据库工程师都必须要知道的。</p>`,87),a=[s];function t(p,r){return n(),o("div",null,a)}const d=e(c,[["render",t],["__file","umlerd.html.vue"]]),h=JSON.parse('{"path":"/technology/engineering/process/umlerd.html","title":"UML和ERD","lang":"zh-CN","frontmatter":{"title":"UML和ERD","icon":"file-pen","category":["开发过程","UML","ERD"],"tag":["开发过程","UML","ERD"],"date":"2022-09-01T00:00:00.000Z","isOriginal":true,"star":true,"description":"UML UML是Unified Modeling Language的英文缩写，中文名称为统一建模语言。它是一套图形化的符号语义系统，可以说是RUP的“副产品”。但有意思的是，它的名气好像比RUP还大，而且RUP虽然已经逐渐没落了，但它却经久不衰。 UML诞生的时间，正是面向对象的软件设计（Object-Oriented Design，OOD）方法论逐步...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/technology/engineering/process/umlerd.html"}],["meta",{"property":"og:site_name","content":"添码座"}],["meta",{"property":"og:title","content":"UML和ERD"}],["meta",{"property":"og:description","content":"UML UML是Unified Modeling Language的英文缩写，中文名称为统一建模语言。它是一套图形化的符号语义系统，可以说是RUP的“副产品”。但有意思的是，它的名气好像比RUP还大，而且RUP虽然已经逐渐没落了，但它却经久不衰。 UML诞生的时间，正是面向对象的软件设计（Object-Oriented Design，OOD）方法论逐步..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://tianmazuo.com/technology/engineering/process/process-14.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"添码座"}],["meta",{"property":"article:tag","content":"开发过程"}],["meta",{"property":"article:tag","content":"UML"}],["meta",{"property":"article:tag","content":"ERD"}],["meta",{"property":"article:published_time","content":"2022-09-01T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"UML和ERD\\",\\"image\\":[\\"https://tianmazuo.com/technology/engineering/process/process-14.png\\",\\"https://tianmazuo.com/technology/engineering/process/process-15.png\\",\\"https://tianmazuo.com/technology/engineering/process/process-16.png\\",\\"https://tianmazuo.com/technology/engineering/process/process-17.png\\",\\"https://tianmazuo.com/technology/engineering/process/process-18.png =600x300\\",\\"https://tianmazuo.com/technology/engineering/process/process-19.png =600x200\\",\\"https://tianmazuo.com/technology/engineering/process/process-20.png =600x200\\",\\"https://tianmazuo.com/technology/engineering/process/process-21.png =600x400\\",\\"https://tianmazuo.com/technology/engineering/process/process-22.png\\",\\"https://tianmazuo.com/technology/engineering/process/process-23.png\\",\\"https://tianmazuo.com/technology/engineering/process/process-24.png\\",\\"https://tianmazuo.com/technology/engineering/process/process-25.png\\",\\"https://tianmazuo.com/technology/engineering/process/process-26.png\\",\\"https://tianmazuo.com/technology/engineering/process/process-27.png\\",\\"https://tianmazuo.com/technology/engineering/process/process-28.png\\",\\"https://tianmazuo.com/technology/engineering/process/process-29.png\\",\\"https://tianmazuo.com/technology/engineering/process/process-30.png\\",\\"https://tianmazuo.com/technology/engineering/process/process-31.png\\",\\"https://tianmazuo.com/technology/engineering/process/process-32.png\\",\\"https://tianmazuo.com/technology/engineering/process/process-33.png\\",\\"https://tianmazuo.com/technology/engineering/process/process-34.png\\",\\"https://tianmazuo.com/technology/engineering/process/process-35.png\\",\\"https://tianmazuo.com/technology/engineering/process/process-36.png\\",\\"https://tianmazuo.com/technology/engineering/process/process-37.png\\",\\"https://tianmazuo.com/technology/engineering/process/process-38.png\\",\\"https://tianmazuo.com/technology/engineering/process/process-39.png\\",\\"https://tianmazuo.com/technology/engineering/process/process-40.png\\",\\"https://tianmazuo.com/technology/engineering/process/process-41.png\\"],\\"datePublished\\":\\"2022-09-01T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"添码座\\",\\"url\\":\\"https://www.tianmazuo.com/about/\\"}]}"]]},"headers":[{"level":2,"title":"UML","slug":"uml","link":"#uml","children":[{"level":3,"title":"用例图","slug":"用例图","link":"#用例图","children":[]},{"level":3,"title":"类图","slug":"类图","link":"#类图","children":[]},{"level":3,"title":"流程图","slug":"流程图","link":"#流程图","children":[]},{"level":3,"title":"状态图","slug":"状态图","link":"#状态图","children":[]},{"level":3,"title":"时序图","slug":"时序图","link":"#时序图","children":[]}]},{"level":2,"title":"ERD","slug":"erd","link":"#erd","children":[]}],"git":{},"readingTime":{"minutes":11.53,"words":3459},"filePathRelative":"technology/engineering/process/umlerd.md","localizedDate":"2022年9月1日","excerpt":"<h2>UML</h2>\\n<p><code>UML</code>是<code>Unified Modeling Language</code>的英文缩写，中文名称为<code>统一建模语言</code>。它是一套图形化的符号语义系统，可以说是<code>RUP</code>的“副产品”。但有意思的是，它的名气好像比<code>RUP</code>还大，而且<code>RUP</code>虽然已经逐渐没落了，但它却经久不衰。</p>\\n<p><code>UML</code>诞生的时间，正是<code>面向对象的软件设计（Object-Oriented Design，OOD）</code>方法论逐步迈向<code>C位</code>的时代。彼时，各种编程语言、设计思想、开发流程、管理方法如雨后春笋般纷纷冒头，给实际的软件开发工作造成了很大的困扰，工程师们<code>语言不通</code>、<code>思想不统一</code>、<code>流程不一致</code>，导致交流想法异常困难。</p>","autoDesc":true}');export{d as comp,h as data};
