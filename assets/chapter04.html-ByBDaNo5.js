import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as a,d as e}from"./app-B5m7CcSj.js";const n={},l=e(`<h2 id="jvm类加载机制" tabindex="-1"><a class="header-anchor" href="#jvm类加载机制"><span>JVM类加载机制</span></a></h2><p>当工程师们准备将写好的源代码变成可执行的程序时，在<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>中会经历这样一个过程。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-01.png" alt="启动一个JVM进程" tabindex="0" loading="lazy"><figcaption>启动一个JVM进程</figcaption></figure><ul><li><p>首先，将源代码文件<code>xxxx.java</code>编译成<code>.class</code>字节码，或者是打成<code>jar</code>包（或<code>war</code>包）。</p></li><li><p>然后，通过类加载器<code>ClassLoader</code>将类的字节码加载到<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>中执行。</p></li></ul><p>上面的图简化了类加载的过程，但其实一个类从加载到使用，整个过程会包括下面的这些步骤，</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-02.png" alt="类加载的完整步骤" tabindex="0" loading="lazy"><figcaption>类加载的完整步骤</figcaption></figure><p><a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>的策略是当需要使用类的时候再加载，而不是一开始就一股脑装进来，这和单例模式中的<code>懒汉模式</code>是一样的。</p><p>类加载中比较关键四个阶段如下图所示。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-03.png" alt="JVM类加载的时机" tabindex="0" loading="lazy"><figcaption>JVM类加载的时机</figcaption></figure><ul><li><p><code>验证阶段</code>：<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>校验加载进来的<code>.class</code>文件是否符合规范。</p></li><li><p><code>准备阶段</code>：给类（包括static修饰的）和变量分配内存空间（仅仅是分配并给一个默认的初始值）。</p></li><li><p><code>解析阶段</code>：把符号引用替换为直接引用，所谓符号引用就是变量名，所谓直接引用则是内存地址。</p></li><li><p><code>初始化阶段</code>：执行类的初始化代码和静态代码块（准备阶段的变量在此赋值）。</p></li></ul><p>至于什么时候真正初始化一个类？以下的几个时机一定会执行初始化动作。</p><ul><li><p>new Object()时。</p></li><li><p>包含main()方法的类。</p></li><li><p>某个类的父类还未初始化，那就必须要先初始化其父类。</p></li></ul><p>而Java的类加载器有下面这么几种，它们的继承关系如图所示。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-04.png" alt="类加载的各阶段" tabindex="0" loading="lazy"><figcaption>类加载的各阶段</figcaption></figure><ul><li><p><code>Bootstrap ClassLoader</code>：启动类加载器，加载<a href="https://www.oracle.com/java/technologies/downloads/archive/" target="_blank" rel="noopener noreferrer">Java</a>核心类（lib中的类），它是顶级类加载器。</p></li><li><p><code>Extension ClassLoader</code>：扩展类加载器，继承自<code>Bootstrap ClassLoader</code>，用于加载<code>lib</code>和<code>ext</code>中的类。</p></li><li><p><code>Application ClassLoader</code>：应用程序类加载器，继承自<code>Extension ClassLoader</code>，加载<code>ClassPath</code>环境变量所指定的路径中存在的类。</p></li><li><p><code>自定义类加载器</code>：根据用户自定义的需求加载类，继承自<code>Application ClassLoader</code>。</p></li></ul><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-05.png" alt="几种类加载器" tabindex="0" loading="lazy"><figcaption>几种类加载器</figcaption></figure><p>当加载类的时候，<code>ClassLoader</code>类加载器的流程如下。</p><ul><li><p>先判断此类是否已经被加载，如果类已经被加载则返回。</p></li><li><p>如果没有被加载，那么会顺着继承结构往上（也就是开始第<code>1.x</code>相关步骤），先委托父加载器看看该类是否已被加载过，有则返回，无则继续向上委托。</p></li><li><p>如果父加载器没找到要加载的类时，再顺着继承结构向下（也就是开始第<code>2.x</code>相关步骤），由子加载器加载。</p></li></ul><p>这就是所谓的<code>双亲委派机制</code>。</p><p>它避免了类的重复加载，确保类的全局唯一性。而且各层职责分明，也保护了程序安全，防止核心包被篡改。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-06.png" alt="双亲委派机制" tabindex="0" loading="lazy"><figcaption>双亲委派机制</figcaption></figure><br><h2 id="jvm内存管理" tabindex="-1"><a class="header-anchor" href="#jvm内存管理"><span>JVM内存管理</span></a></h2><p>就像家里的柴、米、油、盐、酱、醋、茶要分别放在不同的缸子里那样，<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>也会把运行时需要的数据放在不同的<code>储物罐</code>里。</p><p><a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>的存储空间大概都有这么些：方法区、程序计数器、栈、堆。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-07.png" alt=" JVM的“存储空间”" tabindex="0" loading="lazy"><figcaption> JVM的“存储空间”</figcaption></figure><p><code>JDK 1.8</code>之前的版本中，<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>的<code>方法区</code>主要存放从<code>.class</code>加载进来的类。而在<code>JDK 1.8</code>之后改为<code>metaspace（元数据空间）</code>。</p><p><a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>之所以知道程序执行到了哪里，运行了几次，又是怎么被引用的，是程序计数器在起作用。它就是用来记录当前执行的字节码指令的位置的。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-08.png" alt="程序计数器" tabindex="0" loading="lazy"><figcaption>程序计数器</figcaption></figure><p>而由于<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>是支持多线程的，所以每个线程都会有自己的程序计数器。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-09.png" alt="每个线程都有自己的程序计数器" tabindex="0" loading="lazy"><figcaption>每个线程都有自己的程序计数器</figcaption></figure><p>另外一块存储区域就是<code>栈</code>。</p><ul><li><p><a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>栈保存每个方法内的局部变量等数据的区域，每个线程都有自己的<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>栈。</p></li><li><p>线程执行某个方法，就会对该方法的调用创建一个对应的<code>栈帧</code>。</p></li><li><p><code>栈帧</code>里保存这个方法的局部变量表、操作数栈、链接等，可以说是线程自己的王国。</p></li></ul><p>任何方法的调用，都遵循<code>先入栈，再出栈</code>的方式。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-10.png" alt="JVM栈" tabindex="0" loading="lazy"><figcaption>JVM栈</figcaption></figure><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-11.png" alt="JVM栈" tabindex="0" loading="lazy"><figcaption>JVM栈</figcaption></figure><p>最后，正如之前在多线程的内容中所指出的那样，在<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>堆中存放共享数据、对象实例和数组等引用类型。</p><p><a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>栈中的局部变量只是一个引用地址（即指针），指向<a href="https://www.oracle.com/java/technologies/downloads/archive/" target="_blank" rel="noopener noreferrer">Java</a>堆内存里实际存储的对象实例的地址。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-12.png" alt="JVM堆" tabindex="0" loading="lazy"><figcaption>JVM堆</figcaption></figure><p>在知晓JVM的加载机制及各种存储区域后，就可以大致描绘出较为完整的JVM架构轮廓了。</p><ul><li><p>首先，<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>进程启动，类加载器通过双亲委派机制将需要使用的类的字节码加载到<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>中，加载的信息按照<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>规范存放在其不同的内存区域。</p></li><li><p>然后，执行<code>main()</code>方法，并在<code>main线程</code>中将<code>main()</code>方法压入<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>栈。</p></li><li><p>如果需要创建实例对象或数组等引用对象，则在<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>堆中创建，再由<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>栈的局部变量引用<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>堆中实例对象的地址。</p></li><li><p>执行各个不同方法的时候，依次入栈再出栈。</p></li></ul><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-13.png" alt="JVM栈与堆" tabindex="0" loading="lazy"><figcaption>JVM栈与堆</figcaption></figure><p>所有在<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>中创建的对象实例，都是要占用内存资源的，而且内存资源是有限的，不可能无限制地存下去。</p><p>所以，当资源不再被使用时，<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>就需要一个机制将资源回收再利用。</p><p>这就是<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>的垃圾回收机制。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-14.png" alt="JVM垃圾回收" tabindex="0" loading="lazy"><figcaption>JVM垃圾回收</figcaption></figure><br><h2 id="jvm调优案例" tabindex="-1"><a class="header-anchor" href="#jvm调优案例"><span>JVM调优案例</span></a></h2><p>搞清楚了垃圾回收算法、垃圾回收器之后，就可以看看在实际的生产环境中该如何调整<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>参数了。</p><p>仍然以前面的支付系统为例，假设年轻代指定的垃圾回收器为<code>ParNew</code>，老年代指定的垃圾回收器为<code>CMS</code>。</p><p>目前的业务简化后的状况如下。</p><ul><li><p>支付系统遇到节假日大促，<a href="https://baike.baidu.com/item/DAU/4912436" target="_blank" rel="noopener noreferrer">DAU</a>达到了<code>500万</code>，峰值订单量达到了<code>1000笔/秒</code>。</p></li><li><p>现有3台计算机，平均每台至少需承接<code>330笔/秒</code>的订单量。以保守情况预估，按每台计算机每秒承接<code>500笔</code>订单的请求量来计算。</p></li><li><p>计算机的配置为<code>4C8GB</code>，按<code>JVM × 2 = 物理内存</code>来计算，那么<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>应分配到<code>4GB</code>的内存空间。</p></li><li><p><a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>堆分配<code>3GB</code>内存空间，其余留给<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>中的方法区、栈、程序计数器、本地方法栈和其他部分。</p></li><li><p>默认情况下，<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>年轻代和老年代的内存大小比例是<code>1:2</code>。但为了避免年轻代被很快填满，所以这里将年轻代和老年代的比例调整为<code>1:1</code>，也就是都设置为<code>1.5GB</code>。</p></li><li><p>经预估，每笔订单信息输入的数据量大概在<code>1KB</code>左右，而连带的订单详情、优惠券、SKU、物流等信息，需要将订单对象的开销放大<code>10 ~ 20倍</code>，这里按<code>20倍</code>计算。</p></li><li><p>除此之外，订单系统还会有很多相关的其他操作，比如查询、发消息，所以这些算起来，还要在上一步的基础上再扩大<code>10倍</code>的开销。</p></li></ul><p>综合以上信息，整个支付系统的案例背景如下图所示。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-15.png" alt="支付系统的案例背景" tabindex="0" loading="lazy"><figcaption>支付系统的案例背景</figcaption></figure><p>因此，初始的<a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" target="_blank" rel="noopener noreferrer">JVM GC</a>参数就按如下参数配置。</p><ul><li><p>-Xms3072M -Xmx3072M</p></li><li><p>-Xmn1536M</p></li><li><p>-Xss1M</p></li><li><p>-XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M</p></li></ul><p>因为在<code>JDK 1.6</code>之后不再需要<code>-XX:HandlePromotionFailure</code>这个参数，所以就不加了。</p><p>按以上估算，支付系统每秒会生成<code>100MB</code>的数据填充年轻代。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-16.png" alt="年轻代每秒产生的数据" tabindex="0" loading="lazy"><figcaption>年轻代每秒产生的数据</figcaption></figure><p>可以预见，照此速度，15秒之后年轻代就会被填满。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-17.png" alt="年轻代被填满" tabindex="0" loading="lazy"><figcaption>年轻代被填满</figcaption></figure><p>如果<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>参数<code>-XX:SurvivorRatio=8</code>，那么<code>Eden</code>将只有<code>1.2GB</code>，会不等到15秒而提前触发<code>Minor GC</code>。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-18.png" alt="设置-XX:SurvivorRatio=8" tabindex="0" loading="lazy"><figcaption>设置-XX:SurvivorRatio=8</figcaption></figure><p>增加<code>-XX:SurvivorRatio</code>后，<a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" target="_blank" rel="noopener noreferrer">JVM GC</a>参数调整如下。</p><ul><li><p>-Xms3072M -Xmx3072M</p></li><li><p>-Xmn1536M</p></li><li><p>-Xss1M</p></li><li><p>-XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M</p></li><li><p>-XX:SurvivorRatio=8</p></li></ul><p>增加这个参数的目标就是避免年轻代被填得连<code>Minor GC</code>的空间都没有了。但调整<code>Survivor</code>空间时，也要注意几个问题。</p><ul><li><p>有可能会出现<code>Survivor</code>空间不足而直接进入老年代的情况。</p></li><li><p><code>动态年龄判定规则</code>：全部对象大小之和超过<code>Survivor</code>空间<code>50%</code>会直接进入老年代。</p></li><li><p>单次GC之后存活对象大小超过<code>Survivor</code>，则直接进入老年代。</p></li></ul><p>因此，基于如上考虑，一方面可以适当调整年轻代的大小，因为普通业务系统的大部分对象生存周期都很短，根本不应该进入老年代，而是要尽量让它们留在年轻代里。另一方面，也可以增加<code>Survivor</code>空间，根据动态年龄判定规则，增加<code>-XX:TargetSurvivorRatio</code>参数，让可以长久存活的尽量早点进入老年代，给<code>Survivor</code>腾出空间处理新对象。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-19.png" alt="调整年轻代大小" tabindex="0" loading="lazy"><figcaption>调整年轻代大小</figcaption></figure><p>按照上图，<a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" target="_blank" rel="noopener noreferrer">JVM GC</a>参数也需要相应调整。</p><ul><li><p>-Xms3072M -Xmx3072M</p></li><li><p>-Xmn2048M</p></li><li><p>-Xss1M</p></li><li><p>-XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M</p></li><li><p>-XX:SurvivorRatio=8</p></li><li><p>-XX:TargetSurvivorRatio=30</p></li></ul><p>同时，可以降低进入老年代的年龄门槛限制，给<code>Survivor</code>腾出更多空间。那么需要给<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>增加<code>-XX:MaxTenuringThreshold</code>参数了。</p><ul><li><p>-Xms3072M -Xmx3072M</p></li><li><p>-Xmn2048M</p></li><li><p>-Xss1M</p></li><li><p>-XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M</p></li><li><p>-XX:SurvivorRatio=8</p></li><li><p>-XX:TargetSurvivorRatio=30</p></li><li><p>-XX:MaxTenuringThreshold=5</p></li></ul><p>而且可以指定某些超过指定大小的内存对象直接进入老年代，减轻<code>Survivor</code>压力，所以可以给<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>增加<code>-XX:PretenureSizeThreshold</code>参数。</p><ul><li><p>-Xms3072M -Xmx3072M</p></li><li><p>-Xmn2048M</p></li><li><p>-Xss1M</p></li><li><p>-XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M</p></li><li><p>-XX:SurvivorRatio=8</p></li><li><p>-XX:MaxTenuringThreshold=5</p></li><li><p>-XX:TargetSurvivorRatio=30</p></li><li><p>-XX:PretenureSizeThreshold=10MB</p></li></ul><p>之前提过<code>Concurrent Mode Failure</code>的问题，但这种概率极小，不需要为极小概率事件调整<a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" target="_blank" rel="noopener noreferrer">JVM GC</a>设置。</p><p>也没有必要修改执行多少次<code>Full GC</code>之后进行碎片清理，因为经过优化后，<code>Full GC</code>执行次数大大降低了。而且即使是在大促期间，真正的系统压力峰值时间也是有限的，比如持续2小时可能就结束了。如果<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>能做到500单/秒，大约1小时才触发一次<code>Full GC</code>，那么峰值过后，JVM的压力就会小很多，就不会再触发<code>Full GC</code>了。</p><p>最后，要记得给年轻代和老年代指定所要使用的垃圾回收器。</p><ul><li><p>-Xms3072M -Xmx3072M</p></li><li><p>-Xmn2048M</p></li><li><p>-Xss1M</p></li><li><p>-XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M</p></li><li><p>-XX:SurvivorRatio=8</p></li><li><p>-XX:MaxTenuringThreshold=5</p></li><li><p>-XX:TargetSurvivorRatio=30</p></li><li><p>-XX:PretenureSizeThreshold=10MB</p></li><li><p>-XX:+UseParNewGC</p></li><li><p>-XX:+UseConcMarkSweepGC</p></li></ul><p>以上的<a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" target="_blank" rel="noopener noreferrer">JVM GC</a>参数设置，就是根据大促期间的支付系统表现而逐步调整出来的。</p><p>当然，这些设置还需要经过实践的检验，不可能一劳永逸，它还需要在业务运行期间不断根据实际需要而进行调整。</p><br><h2 id="full-gc实践案例" tabindex="-1"><a class="header-anchor" href="#full-gc实践案例"><span>Full GC实践案例</span></a></h2><p>之前已经讨论过几种情况下的GC日志，不过都属于小打小闹。下面就弄出个<code>Full GC</code>看看。</p><p>JVM基础参数如下。</p><ul><li><p>-Xms20M -Xmx20M -Xmn10M</p></li><li><p>-XX:SurvivorRatio=8</p></li><li><p>-XX:PretenureSizeThreshold=3M</p></li><li><p>-XX:+UseParNewGC</p></li><li><p>-XX:+UseConcMarkSweepGC</p></li><li><p>-verbose:gc</p></li><li><p>-XX:+PrintGCDetails</p></li><li><p>-XX:+PrintGCDateStamps</p></li><li><p>-Xloggc:[日志目录]/gc.log</p></li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">/**</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> * 在命令行中执行代码时需要先注释掉package相关的行再用javac命令编译</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> * 否则会出现&quot;找不到主类&quot;的错误</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> *</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> */</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">package</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;"> cn.javabook.chapter04</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">/**</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> * 代码运行基于如下命令（可修改并拷贝后执行）</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> *</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> * 注意JVM参数的不同：-XX:PretenureSizeThreshold=3M</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> *</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> * cd [xxx.java源代码所在的目录]</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> * javac ExperimentObjectE.java</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> * java -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=3M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps -verbose:gc -Xloggc:[指定目录地址]\\gc.log ExperimentObjectE</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> */</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ExperimentObjectE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">        byte</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">array1</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> byte</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1024</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1024</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        array1 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">        byte</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">array2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> byte</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1024</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1024</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">        byte</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">array3</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> byte</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1024</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1024</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">        byte</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">array4</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> byte</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1024</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1024</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">        byte</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">array5</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> byte</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">128</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1024</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">        byte</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">array6</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> byte</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1024</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1024</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码执行前的内存分配如下图所示。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-20.png" alt="代码执行前内存分配" tabindex="0" loading="lazy"><figcaption>代码执行前内存分配</figcaption></figure><p>因为<code>array1</code>的大小超过了<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>参数<code>-XX:PretenureSizeThreshold</code>规定的大小，所以就被直接分配到了老年代。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-21.png" alt="array1被分配到老年代" tabindex="0" loading="lazy"><figcaption>array1被分配到老年代</figcaption></figure><p>接着分配内存给<code>array2</code>、<code>array3</code>、<code>array4</code>和<code>array5</code>，此时<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>内存状态如下图所示。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-22.png" alt="给array2 ~ array5分配内存空间" tabindex="0" loading="lazy"><figcaption>给array2 ~ array5分配内存空间</figcaption></figure><p>接着给<code>array6</code>分配空间，此时<code>Eden区</code>空间不足，触发<code>Minro GC</code>，GC日志精简后如下图所示。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-23.png" alt="因给array6分配空间不足触发的Minor GC" tabindex="0" loading="lazy"><figcaption>因给array6分配空间不足触发的Minor GC</figcaption></figure><p><code>ParNew (promotion failed): 7299K-&gt;8065K(9216K)</code>表示回收失败，因为<code>array2</code>、<code>array3</code>、<code>array4</code>、<code>array5</code>、<code>array6</code>都是强引用，一个都回收不掉，且所需空间之和超过<code>Eden</code>区的8MB容量。</p><p>而当尝试往老年代中存放时，发现老年代也放不下，因为已有一个大小为4MB的弱引用<code>array1</code>，故进而触发老年代的<code>Major GC</code>。</p><p><code>[CMS: 8194K-&gt;6897K(10240K), ......]</code>表明老年代空间从GC前的8MB变为GC后的6MB，同时触发元空间的GC（<code>Metaspace GC</code>）。</p><p>从8MB变为6MB的过程如下。</p><ul><li>先将<code>array3</code>和<code>array4</code>放入老年代。</li></ul><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-24.png" alt="先将array3和array4放入老年代" tabindex="0" loading="lazy"><figcaption>先将array3和array4放入老年代</figcaption></figure><ul><li>触发<code>CMS</code>的<code>Full GC</code>，回收掉无用的数组<code>array1</code>。</li></ul><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-25.png" alt="用CMS回收掉无用的array1" tabindex="0" loading="lazy"><figcaption>用CMS回收掉无用的array1</figcaption></figure><ul><li>将<code>array2</code>和<code>arrya5</code>再放进去，因此老年代的大小就是<code>array2 + array3 + array4 + array5 = 3 × 2M + 128K</code>。</li></ul><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-26.png" alt="再将array2和arrya5放到老年代" tabindex="0" loading="lazy"><figcaption>再将array2和arrya5放到老年代</figcaption></figure><ul><li>再将<code>array6</code>放到<code>Eden</code>区。</li></ul><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-27.png" alt="再将array6放到Eden区" tabindex="0" loading="lazy"><figcaption>再将array6放到Eden区</figcaption></figure><p>此时的<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>内存分配状态正是GC日志所显示的那样：<code>Eden</code>区的<code>28%</code>被<code>array6</code>填充，而老年代的<code>6897KB</code>，正是被<code>array2</code>、<code>array3</code>、<code>array4</code>、<code>array5</code>及其他存活对象霸占。</p><br><h2 id="可视化工具" tabindex="-1"><a class="header-anchor" href="#可视化工具"><span>可视化工具</span></a></h2><p><a href="https://en.wikipedia.org/wiki/JConsole" target="_blank" rel="noopener noreferrer">jconsole</a>不仅可以让工程师看到线程的的运行信息，而且也能看到关于<a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" target="_blank" rel="noopener noreferrer">JVM GC</a>的信息。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-28.png" alt="jconsole展示的JVM GC信息" tabindex="0" loading="lazy"><figcaption>jconsole展示的JVM GC信息</figcaption></figure><p>除此之外，还有几个比<a href="https://en.wikipedia.org/wiki/JConsole" target="_blank" rel="noopener noreferrer">jconsole</a>相对更专业的工具，可以获得更多与GC相关的信息。</p><p>想使用<code>jstat</code>要具备两个条件。</p><ul><li><p>通过<code>jps</code>得到正在运行的<a href="https://www.oracle.com/java/technologies/downloads/archive/" target="_blank" rel="noopener noreferrer">Java</a>进程的<code>PID</code>。</p></li><li><p>通过命令选项告诉<code>jstat</code>想得到什么结果（选项列表可以用<code>jstat -options得到</code>）。</p></li></ul><p>至于<code>jstat</code>的命令参数和<code>-options</code>中各个选项的意义就不在这里赘述。</p><ul><li><code>jstat -gc [PID]</code>命令用于查看JVM内存使用和GC概要信息。</li></ul><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-29.png" alt="jstat命令" tabindex="0" loading="lazy"><figcaption>jstat命令</figcaption></figure><p>因为要顾及显示问题，所以当字体放大以后，界面被压缩了。但还是能清楚地看到<code>jstat -gc</code>和<code>jstat -gcutil</code>所列出的数据项。</p><ul><li><p><code>S0C/S1C</code>：From/To Servivor区，也就是S0/S1的大小。</p></li><li><p><code>S0U/S1U</code>：From/To Servivor区，也就是S0/S1已使用的内存大小。</p></li><li><p><code>EC/EU</code>：Eden区大小及其当前使用的内存大小。</p></li><li><p><code>OC/OU</code>：老年代及其当前使用的内存大小。</p></li><li><p><code>MC/MU</code>：元空间及其当前使用的内存大小。</p></li><li><p><code>CCSC/CCSU</code>：类空间及其当前使用的内存大小。</p></li><li><p><code>YGC</code>：运行到目前为止Young GC的次数。</p></li><li><p><code>YGCT</code>：Young GC的耗时。</p></li><li><p><code>FGC</code>：运行到目前为止Full GC的次数。</p></li><li><p><code>FGCT</code>：Full GC的耗时。</p></li><li><p><code>GCT</code>：所有GC的总耗时。</p></li></ul><p>只不过<code>-gcutil</code>所列出的信息更粗略而已。其他几个和GC相关的命令如下。</p><ul><li><p><code>jstat -gccapacity [PID]</code>：查看整个<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>堆中各代内存大小、对象实例及其使用状况。</p></li><li><p><code>jstat -gcnew [PID]</code>：查看年轻代GC状况，TT和MTT分别表示对象在年轻代的存活年龄和最大存活年龄。</p></li><li><p><code>jstat -gcnewcapacity [PID]</code>：查看年轻代内存大小、对象实例的信息及其使用状况。</p></li><li><p><code>jstat -gcold [PID]</code>：查看老年代GC状况。</p></li><li><p><code>jstat -gcoldcapacity [PID]</code>：查看老年代内存大小、对象实例的信息及其使用状况。</p></li><li><p><code>jstat -gcmetacapacity [PID]</code>：元空间内存大小、对象实例的信息及其使用状况。</p></li></ul><p>常用<code>jsta -gc [PID] [更新频率（毫秒）] [更新次数]</code>命令来获得以下信息。</p><ul><li><p>查看年轻代对象增长速率。</p></li><li><p>推算Minor GC的触发频率和耗时。</p></li><li><p>推算Minor GC后多少对象存活。</p></li><li><p>推算Minor GC后有多少对象进入老年代。</p></li><li><p>查看老年代对象的增长速率。</p></li><li><p>推算Full GC的触发频率和耗时。</p></li></ul><p>例如，下面的<code>jstat -gc 644 1000 3</code>命令表示查看GC情况，每秒更新，共3次。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-30.png" alt="jstat命令" tabindex="0" loading="lazy"><figcaption>jstat命令</figcaption></figure><p>如果发现<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>内存占用量特别大，想知道是哪个对象实例搞的鬼，那么就要轮到<code>jmap</code>出场了。</p><p>通过<code>jmap -heap [PID]</code>命令，可以知道到底是哪些对象占据了那么多的内存。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-31.png" alt="jmap命令" tabindex="0" loading="lazy"><figcaption>jmap命令</figcaption></figure><p>从上图可以看出，<code>jmap</code>命令显示的信息和GC日志中<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>堆内存状况的数据有些类似。</p><p>使用<code>jmap</code>也可以了解系统运行时的对象分布，例如<code>jmap -histo [PID]</code>命令将结果按照各种对象占用内存空间的大小降序排列，占用内存最多的在最上。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-32.png" alt="jmap命令" tabindex="0" loading="lazy"><figcaption>jmap命令</figcaption></figure><p>而<code>jhat</code>命令最好用的地方就是可以通过浏览器的方式看到生成的堆内存快照，不过它需要<code>jmap</code>的配合。</p><ul><li><p>先用<code>jmap</code>生成堆内存快照：<code>jmap -dump:live,format=b,file=C:\\dump.hprof 644</code>。</p></li><li><p>再用<code>jhat</code>读取这个快照文件：<code>jhat C:\\dump.hprof</code>。</p></li></ul><p>这两步过程如下图所示。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-33.png" alt="jmap和jhat命令配合使用" tabindex="0" loading="lazy"><figcaption>jmap和jhat命令配合使用</figcaption></figure><p><code>jhat</code>默认的访问端口是<code>7000</code>，在浏览器中打开如下地址即可：<a href="http://localhost:7000" target="_blank" rel="noopener noreferrer">http://localhost:7000</a>。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-34.png" alt="在浏览器的7000端口中查看JVM堆内存使用状况" tabindex="0" loading="lazy"><figcaption>在浏览器的7000端口中查看JVM堆内存使用状况</figcaption></figure><br><h2 id="可视化案例实践一" tabindex="-1"><a class="header-anchor" href="#可视化案例实践一"><span>可视化案例实践一</span></a></h2><p>有一个企业内部的自研报表系统，它的<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>配置除了将 <code>-Xms20M -Xmx20M -Xmn10M -XX:PretenureSizeThreshold=10M</code>改为<code>-Xms200M -Xmx200M -Xmn100M -XX:PretenureSizeThreshold=3M</code>以外，其运行环境、其他<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>参数配置和前面的<code>Full GC实践案例</code>保持一致。</p><p>这个自研报表系统的核心代码如下。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">/**</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> * 在命令行中执行代码时需要先注释掉package相关的行再用javac命令编译</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> * 否则会出现&quot;找不到主类&quot;的错误</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> *</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> */</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">package</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;"> cn.javabook.chapter04</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> java.util.concurrent.TimeUnit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">/**</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> * 代码运行基于如下命令（可修改并拷贝后执行）</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> * cd [xxx.java源代码所在的目录]</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> * javac ToolsPracticeA.java</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> * java -Xms200M -Xmx200M -Xmn100M -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=3M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps -verbose:gc -Xloggc:[指定目录地址]\\gc.log ToolsPracticeA</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> */</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ToolsPracticeA</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> loadData</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Exception</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">        byte</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">data</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 50</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i++) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            data </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> byte</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1024</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        data </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        TimeUnit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">MILLISECONDS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sleep</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Exception</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        // 这里休眠30秒纯粹是为了准备好命令行的相关准备工作，如通过jps查看PID以及输入命令所需的时间</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        TimeUnit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">MILLISECONDS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sleep</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">30000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">            loadData</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>参数可以知道如下事实。</p><ul><li><p>整个<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>堆内存大小200MB。</p></li><li><p>年轻代100MB，其中Eden区80MB，S0和S1各10MB。</p></li><li><p>老年代100MB。</p></li><li><p>使用<code>ParNew</code> + <code>CMS</code>垃圾回收算法。</p></li><li><p>分配的<code>对象大小 ＞ 3M</code>时直接进入老年代。</p></li><li><p>年轻代<code>对象年龄 ＞ 15</code>时进入老年代。</p></li></ul><p>启动程序运行，通过<code>jps</code>命令得到<code>PID</code>，然后使用<code>jstat -gc [PID]</code>或者<code>jstat -gc [PID] 1000 1000</code>。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-35.png" alt="使用jstat命令查看GC情况" tabindex="0" loading="lazy"><figcaption>使用jstat命令查看GC情况</figcaption></figure><p>从上图可以看出，Eden区的使用空间从第1秒的7577.5，经过15秒之后逐步升至77588.4，当第16秒再分配对象时，发现已经超过Eden区空间的大小时，触发第1次YGC（也就是Minor GC），此时S1也从0上升至 796.8。</p><p>程序继续执行，当经过17次之后，Eden区空间大小又从1805.5飙升至81920.0，于是当第18次再分配对象时，触发第2次YGC，导致S0从0上升至 951.2，而S1则从796.8降至0，Eden区则降至5243.7。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-36.png" alt="使用jstat命令查看GC情况" tabindex="0" loading="lazy"><figcaption>使用jstat命令查看GC情况</figcaption></figure><p>持续观察观察一段时间，会发现每隔10多次，就会触发一次YGC，而年轻代的S0、S1和Eden这三个地方的内存空间，像变魔术一样倒腾来倒腾去，如此循环交替。</p><p>到第16次GC时，老年代使用空间OU变为655.7，并且一直稳定在这一数字上下，之后不管再有多少次YGC，其变化也可忽略不计。</p><p>随着YGC次数的增多，除了Eden区不停变化外，S0U和S1U也趋向于0。</p><p>这一数据变化趋势，通过下面三张图可以很清楚地看出来。这种稳定的数据变化也几乎不会引起Full GC。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-37.png" alt="持续观察GC输出" tabindex="0" loading="lazy"><figcaption>持续观察GC输出</figcaption></figure><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-38.png" alt="持续观察GC输出" tabindex="0" loading="lazy"><figcaption>持续观察GC输出</figcaption></figure><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-39.png" alt="持续观察GC输出" tabindex="0" loading="lazy"><figcaption>持续观察GC输出</figcaption></figure><br><h2 id="可视化案例实践二" tabindex="-1"><a class="header-anchor" href="#可视化案例实践二"><span>可视化案例实践二</span></a></h2><p>另一个企业内部的日志采集组件，它的JVM配置除了将 <code>-Xms20M -Xmx20M -Xmn10M -XX:PretenureSizeThreshold=10M</code>改为<code>-Xms200M -Xmx200M -Xmn100M -XX:PretenureSizeThreshold=20M</code>以外，其运行环境、其他<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>参数配置和<code>Full GC实践案例</code>保持一致。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">/**</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> * 在命令行中执行代码时需要先注释掉package相关的行再用javac命令编译</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> * 否则会出现&quot;找不到主类&quot;的错误</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> *</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> */</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">package</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;"> cn.javabook.chapter04</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> java.util.concurrent.TimeUnit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">/**</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> * 代码运行基于如下命令（可修改并拷贝后执行）</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> *</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> * 注意JVM参数的不同：-XX:PretenureSizeThreshold=20M</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> *</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> * cd [xxx.java源代码所在的目录]</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> * javac ToolsPracticeB.java</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> * java -Xms200M -Xmx200M -Xmn100M -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=20M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps -verbose:gc -Xloggc:[指定目录地址]\\gc.log ToolsPracticeB</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> *</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> */</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ToolsPracticeB</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> loadData</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Exception</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">        byte</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">data</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i++) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            data </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> byte</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1024</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1024</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        data </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">        byte</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">data1</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> byte</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1024</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1024</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">        byte</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">data2</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> byte</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1024</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1024</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">        byte</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">data3</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> byte</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1024</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1024</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        data3 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> byte</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1024</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1024</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        TimeUnit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">MILLISECONDS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sleep</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Exception</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        // 这里休眠30秒纯粹是为了准备好命令行的相关准备工作，如通过jps查看PID以及输入命令所需的时间</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        TimeUnit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">MILLISECONDS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sleep</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">30000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">            loadData</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>参数可以知道如下事实。</p><ul><li><p>整个<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>堆内存大小200MB。</p></li><li><p>年轻代100MB，其中Eden区80MB，S0和S1各10MB。</p></li><li><p>老年代100MB。</p></li><li><p>使用<code>ParNew</code> + <code>CMS</code>垃圾回收算法。</p></li><li><p>分配的<code>对象大小 ＞ 20M</code>时直接进入老年代。</p></li><li><p>年轻代<code>对象年龄 ＞ 15</code>时进入老年代。</p></li></ul><p>启动程序运行，通过<code>jps</code>命令得到<code>PID</code>，然后使用<code>jstat -gc [PID]</code>或者<code>jstat -gc [PID] 1000 1000</code>。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-40.png" alt="使用jstat命令查看GC情况" tabindex="0" loading="lazy"><figcaption>使用jstat命令查看GC情况</figcaption></figure><ul><li><p>第1次<code>YGC</code>后，就有30MB对象存活，S0和S1都放不下，直接进入老年代，因此<code>OU</code>是30722.1。</p></li><li><p>每隔1秒就触发1次<code>YGC</code>，每次都有10 ~ 20MB存活对象进入老年代。</p></li><li><p>当<code>YGC</code>转移过来的存活对象老年代放不下或者空间也快占满时，触发<code>Full GC</code>，也就是最右边显示的<code>FGC</code>。</p></li><li><p><code>Full GC</code>也频繁触发，基本上几秒钟就触发1次。</p></li><li><p>从第17次<code>YGC</code>开始，<code>S0U</code>=<code>S1U</code>=0，而且到第146次之后，<code>Full GC</code>就不再被触发了。</p></li></ul><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-41.png" alt="使用jstat命令查看GC情况" tabindex="0" loading="lazy"><figcaption>使用jstat命令查看GC情况</figcaption></figure><ul><li>可以发现<code>YGC</code>耗时比<code>FGC</code>要慢很多，基本上是10倍左右（<code>YGCT</code> / <code>FGCT</code> ≈ 10）的差距。这是因为它触发<code>Full GC</code>后，必须等<code>Full GC</code>执行完了，老年代有了足够的空间才能继续往里放存活对象。</li></ul><p>可以发现虽然到了第146次之后，系统逐渐稳定下来，几乎不再触发<code>FGC</code>，但初期却<code>抖动</code>得厉害。且它最大的问题是<code>YGC</code>后每次存活的对象太多，导致S0或S1空间不足，直接进入老年代，频繁触发<code>Full GC</code>。</p><p>针对这个问题，其实只需要调大年轻代即可，即将<code>-XX:SurvivorRatio=8</code>调整为<code>-XX:SurvivorRatio=2</code>，也就是<code>Eden : S0 : S1</code> = <code>2 : 1 : 1</code>，让S0或S1的空间从10MB变为25MB。</p><p>在修改了<a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener noreferrer">JVM</a>的参数<code>-XX:SurvivorRatio</code>之后，再次用<code>jstat</code>命令查看GC情况。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c04-42.png" alt="使用jstat命令查看GC情况" tabindex="0" loading="lazy"><figcaption>使用jstat命令查看GC情况</figcaption></figure><p>可以明显看出，不管<code>YGC</code>发生多少次，<code>Full GC</code>再也没有被触发过。而且<code>S0U</code>和<code>S1U</code>也变为了0。</p><p><code>OU</code>经过15次<code>YGC</code>后稳定在664.0，其后续微小变化可以忽略不计。</p>`,174),t=[l];function p(o,r){return a(),s("div",null,t)}const d=i(n,[["render",p],["__file","chapter04.html.vue"]]),c=JSON.parse('{"path":"/book/prune/chapter04.html","title":"《第4章 JVM GC》节略部分","lang":"zh-CN","frontmatter":{"title":"《第4章 JVM GC》节略部分","icon":"receipt","category":["电子书","节略章节合辑"],"tag":["电子书","节略章节合辑"],"date":"2024-07-08T00:00:00.000Z","isOriginal":true,"star":true,"description":"JVM类加载机制 当工程师们准备将写好的源代码变成可执行的程序时，在JVM中会经历这样一个过程。 启动一个JVM进程启动一个JVM进程 首先，将源代码文件xxxx.java编译成.class字节码，或者是打成jar包（或war包）。 然后，通过类加载器ClassLoader将类的字节码加载到JVM中执行。 上面的图简化了类加载的过程，但其实一个类从加载...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/book/prune/chapter04.html"}],["meta",{"property":"og:site_name","content":"添码座"}],["meta",{"property":"og:title","content":"《第4章 JVM GC》节略部分"}],["meta",{"property":"og:description","content":"JVM类加载机制 当工程师们准备将写好的源代码变成可执行的程序时，在JVM中会经历这样一个过程。 启动一个JVM进程启动一个JVM进程 首先，将源代码文件xxxx.java编译成.class字节码，或者是打成jar包（或war包）。 然后，通过类加载器ClassLoader将类的字节码加载到JVM中执行。 上面的图简化了类加载的过程，但其实一个类从加载..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://tianmazuo.com/book/prune/mybook-c04-01.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"添码座"}],["meta",{"property":"article:tag","content":"电子书"}],["meta",{"property":"article:tag","content":"节略章节合辑"}],["meta",{"property":"article:published_time","content":"2024-07-08T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"《第4章 JVM GC》节略部分\\",\\"image\\":[\\"https://tianmazuo.com/book/prune/mybook-c04-01.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-02.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-03.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-04.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-05.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-06.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-07.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-08.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-09.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-10.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-11.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-12.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-13.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-14.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-15.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-16.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-17.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-18.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-19.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-20.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-21.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-22.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-23.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-24.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-25.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-26.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-27.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-28.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-29.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-30.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-31.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-32.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-33.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-34.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-35.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-36.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-37.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-38.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-39.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-40.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-41.png\\",\\"https://tianmazuo.com/book/prune/mybook-c04-42.png\\"],\\"datePublished\\":\\"2024-07-08T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"添码座\\",\\"url\\":\\"https://www.tianmazuo.com/about/\\"}]}"]]},"headers":[{"level":2,"title":"JVM类加载机制","slug":"jvm类加载机制","link":"#jvm类加载机制","children":[]},{"level":2,"title":"JVM内存管理","slug":"jvm内存管理","link":"#jvm内存管理","children":[]},{"level":2,"title":"JVM调优案例","slug":"jvm调优案例","link":"#jvm调优案例","children":[]},{"level":2,"title":"Full GC实践案例","slug":"full-gc实践案例","link":"#full-gc实践案例","children":[]},{"level":2,"title":"可视化工具","slug":"可视化工具","link":"#可视化工具","children":[]},{"level":2,"title":"可视化案例实践一","slug":"可视化案例实践一","link":"#可视化案例实践一","children":[]},{"level":2,"title":"可视化案例实践二","slug":"可视化案例实践二","link":"#可视化案例实践二","children":[]}],"git":{},"readingTime":{"minutes":21.52,"words":6455},"filePathRelative":"book/prune/chapter04.md","localizedDate":"2024年7月8日","excerpt":"<h2>JVM类加载机制</h2>\\n<p>当工程师们准备将写好的源代码变成可执行的程序时，在<a href=\\"https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">JVM</a>中会经历这样一个过程。</p>\\n<figure><img src=\\"https://tianmazuo.com/book/prune/mybook-c04-01.png\\" alt=\\"启动一个JVM进程\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>启动一个JVM进程</figcaption></figure>","autoDesc":true}');export{d as comp,c as data};
