import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,o as d,d as t}from"./app-B5m7CcSj.js";const a={},c=t('<h2 id="undo-log版本链" tabindex="-1"><a class="header-anchor" href="#undo-log版本链"><span>undo log版本链</span></a></h2><p><a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>中的每条数据其实都有两个隐藏字段。</p><ul><li><p><code>trx_id</code>：最近一次更新这条数据的事务ID。</p></li><li><p><code>roll_pointer</code>：指向更新事务发生之前生成的<code>undo log</code>。</p></li></ul><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-37.png" alt="undo log版本链" tabindex="0" loading="lazy"><figcaption>undo log版本链</figcaption></figure><p>此时<code>事务B</code>也修改了数据，那么更新之前会生成一个<code>undo log</code>，并让新数据的<code>roll_pointer</code>指向这个<code>undo log</code>的回滚日志。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-38.png" alt="undo log版本链" tabindex="0" loading="lazy"><figcaption>undo log版本链</figcaption></figure><p>假设<code>事务C</code>也要修改数据，同样的道理。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-39.png" alt="undo log版本链" tabindex="0" loading="lazy"><figcaption>undo log版本链</figcaption></figure><p>因此，从<code>事务A</code>到<code>事务C</code>，就形成了通过<code>roll_pointer</code>指针串起来的<code>undo log</code>版本链。</p><br><h2 id="readview机制" tabindex="-1"><a class="header-anchor" href="#readview机制"><span>ReadView机制</span></a></h2><p>执行事务的时候，会生成一个叫做<code>ReadView</code>的东西，它有四个关键的字段。</p><ul><li><p><code>m_ids</code>：正在执行但还未提交的活跃事务ID集合。</p></li><li><p><code>min_trx_id</code>：<code>m_ids</code>中最小的事务ID值。</p></li><li><p><code>max_trx_id</code>：下一个要生成的事务ID值，也是<code>m_ids</code>中最大的事务ID值，值一般是最大<code>trx_id + 1</code>。</p></li><li><p><code>creator_trx_id</code>：创建<code>ReadView</code>的事务ID值。</p></li></ul><p>假设数据库中有一行原始数据，事务ID=1。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-40.png" alt="原始数据" tabindex="0" loading="lazy"><figcaption>原始数据</figcaption></figure><p>此时过来两个请求，分别代表<code>事务A</code>（ID=2）和<code>事务B</code>（ID=3），<code>事务A</code>执行读请求，<code>事务B</code>执行写请求。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-41.png" alt="事务请求" tabindex="0" loading="lazy"><figcaption>事务请求</figcaption></figure><p>现在事务A开启一个ReadView。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-42.png" alt="事务A开启ReadView" tabindex="0" loading="lazy"><figcaption>事务A开启ReadView</figcaption></figure><p>整个流程为：</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-43.png" alt="ReadView机制" tabindex="0" loading="lazy"><figcaption>ReadView机制</figcaption></figure><ul><li><p><code>事务A</code>第一次查询数据时，会先判断当前这行数据的<code>trx_id</code>是否小于<code>min_trx_id</code>，如果小于，就可以正常查询获得数据。</p></li><li><p><code>事务B</code>接着把这条数据改为了数据B，然后把<code>trx_id</code>设为自己的<code>trx_id</code>，同时生成一个<code>undo log</code>链指向之前的数据，<code>事务B</code>提交。</p></li><li><p><code>事务A</code>此时再次查询，如果<code>min_trx_id &lt; trx_id &lt; max_trx_id</code>，说明这条数据的事务可能是跟自己差不多同时开启的，为了验证，继续去查，看<code>trx_id</code>是否在<code>m_ids</code>中。</p></li><li><p>如果<code>trx_id ∈ m_ids</code>，说明这行数据是不能查询的，会顺着这条数据的<code>roll_pointer</code>去查<code>undo log</code>版本链。</p></li><li><p>当找到最近一条数据的<code>trx_id &lt; min_trx_id</code>时，说明该事务必然在<code>事务A</code>开启前就已提交，可以放心地查询数据了。</p></li></ul><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-44.png" alt="ReadView机制" tabindex="0" loading="lazy"><figcaption>ReadView机制</figcaption></figure><ul><li><p>接着<code>事务A</code>更新了这行数据，<code>trx_id</code>修改为2，同时生成<code>undo log</code>。</p></li><li><p><code>事务A</code>继续发送读请求，发现<code>trx_id = 2</code>，就是自己的值，可以直接查询。</p></li><li><p><code>事务A</code>执行时，突然插入了<code>事务C</code>，更新事务A查询的那行记录并提交，导致<code>trx_id = 4</code>且大于<code>max_trx_id</code>，说明<code>事务A</code>已经不能再查询到最新数据了。</p></li><li><p><code>事务A</code>顺着<code>undo log</code>往前翻，找到<code>trx_id &lt;= min_trx_id</code>或者<code>trx_id == creator_trx_id</code>的记录，读取这个版本的数据值。</p></li></ul><p>通过<code>undo log多版本链</code> + 事务启动时开启的<code>ReadView</code>，就可以准确地知道应该读取哪个版本的数据。并且保证多个事务混合在一起时相互之间不会干扰，也就实现了多事务并发执行时的数据隔离特性。</p><p><code>ReadView</code>实际上是一套基于<code>undo log</code>的视图机制：事务自己更新的数据，或者是在它之前更新的数据，都是可读的，但如果生成<code>ReadView</code>后有别的事务修改了数据，当前事务是读不到的。</p><br><h2 id="read-committed隔离级别" tabindex="-1"><a class="header-anchor" href="#read-committed隔离级别"><span>Read Committed隔离级别</span></a></h2><p><code>Read Committed</code>隔离级别可以消除脏读，但是无法消除<code>可重复读</code>和<code>幻读</code>问题。</p><p>基于<code>ReadView</code>实现<code>RC</code>隔离级别的核心要点在于：每次事务发起查询，都会重新生成一个<code>ReadView</code>视图，数据库中有一行数据，是之前的事务更新进去的，但当前有两个活跃事务，<code>事务A</code>（trx_id=2）和<code>事务B</code>（trx_id=3）。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-45.png" alt="Read Committed" tabindex="0" loading="lazy"><figcaption>Read Committed</figcaption></figure><p><code>事务B</code>发起写请求，更新了数据，同时会生成一个<code>undo log</code>。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-46.png" alt="事务B发起写请求" tabindex="0" loading="lazy"><figcaption>事务B发起写请求</figcaption></figure><p>此时，<code>事务A</code>发起读请求，同时生成一个<code>ReadView</code>。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-47.png" alt="事务A发起读请求" tabindex="0" loading="lazy"><figcaption>事务A发起读请求</figcaption></figure><p><code>事务A</code>查询时，发现当前数据的<code>trx_id = 3</code>，在<code>m_ids</code>中（因<code>事务B</code>还未提交，属于活跃事务），但依据<code>ReadView</code>机制，<code>事务A</code>是无法读取到<code>事务B</code>修改的数据的。</p><p><code>事务A</code>顺着<code>undo log</code>往前翻，找到某个版本的<code>trx_id = 1</code>，很明显<code>trx_id &lt; min_trx_id</code>，<code>事务A</code>就可以读取到这个版本的数据了。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-48.png" alt="Read Committed隔离级别" tabindex="0" loading="lazy"><figcaption>Read Committed隔离级别</figcaption></figure><p>接着，<code>事务B</code>提交了——紧接着，<code>事务A</code>再次发起读请求，并重新生成一个<code>ReadView</code>，此时<code>ReadView</code>的<code>m_ids</code>中已经没有<code>事务B</code>的ID了。</p><p>当<code>事务A</code>查询时，发现数据的<code>trx_id = 3 &lt; max_trx_id</code>且不在<code>m_ids</code>中，因此可以读取数据。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-49.png" alt="Read Committed隔离级别" tabindex="0" loading="lazy"><figcaption>Read Committed隔离级别</figcaption></figure><p>实际上，基于<code>undo log多版本链</code> + <code>ReadView机制</code>实现的多事务并发执行的<code>RC</code>、<code>RR</code>隔离级别，就是数据库的<code>MVCC多版本并发控制机制</code>在起作用。</p><p>其本质是当多个事务并发地运行且读写同一批数据的时候，应该如何协调相互之间的数据可见性。</p><br><h2 id="repeatable-read隔离级别" tabindex="-1"><a class="header-anchor" href="#repeatable-read隔离级别"><span>Repeatable Read隔离级别</span></a></h2><p><code>Repeatable Read（简称RR）</code>隔离级别是<a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>默认的隔离级别，还可以解决标准<code>SQL</code>隔离级别无法解决的<code>幻读</code>问题。</p><p>在<code>RR</code>隔离级别下，同一条数据，事务无论读多少次，都是同一个值——哪怕别的事务提交了也是如此。</p><p>假设数据初始状态。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-50.png" alt="数据初始状态" tabindex="0" loading="lazy"><figcaption>数据初始状态</figcaption></figure><p><code>事务A</code>发起读请求，生成<code>ReadView</code>。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-51.png" alt="事务A发起读请求" tabindex="0" loading="lazy"><figcaption>事务A发起读请求</figcaption></figure><p>接着<code>事务B</code>更新了这条数据。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-52.png" alt="事务B更新数据" tabindex="0" loading="lazy"><figcaption>事务B更新数据</figcaption></figure><p>因为没有重新生成<code>ReadView</code>，因此<code>m_ids</code>的值保持不变，依据<code>ReadView</code>规则，如果此时<code>事务A</code>再次查询，是查询不到修改后的数据的，只能顺着<code>undo log</code>往前翻。</p><p>基于严格的<code>ReadView</code>规则，就此解决<code>脏读</code>、<code>不可重复读</code>和<code>幻读</code>问题。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-53.png" alt="严格的ReadView规则" tabindex="0" loading="lazy"><figcaption>严格的ReadView规则</figcaption></figure><br><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><ul><li><p><code>MVCC</code> = <code>undo log版本链</code> + <code>ReadView机制</code>。</p></li><li><p><a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>默认是<code>RR隔离级别</code>。</p></li><li><p><a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>依靠<code>MVCC</code>解决了<code>脏读</code>、<code>不可重复读</code>与<code>幻读</code>问题。</p></li></ul>',59),i=[c];function l(n,p){return d(),o("div",null,i)}const g=e(a,[["render",l],["__file","mvcc.html.vue"]]),s=JSON.parse('{"path":"/technology/database/mysql/mvcc.html","title":"MVCC","lang":"zh-CN","frontmatter":{"title":"MVCC","icon":"table","category":["数据库","MySQL"],"tag":["数据库","MySQL","MVCC"],"date":"2023-05-07T00:00:00.000Z","isOriginal":true,"star":true,"description":"undo log版本链 MySQL中的每条数据其实都有两个隐藏字段。 trx_id：最近一次更新这条数据的事务ID。 roll_pointer：指向更新事务发生之前生成的undo log。 undo log版本链undo log版本链 此时事务B也修改了数据，那么更新之前会生成一个undo log，并让新数据的roll_pointer指向这个undo ...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/technology/database/mysql/mvcc.html"}],["meta",{"property":"og:site_name","content":"添码座"}],["meta",{"property":"og:title","content":"MVCC"}],["meta",{"property":"og:description","content":"undo log版本链 MySQL中的每条数据其实都有两个隐藏字段。 trx_id：最近一次更新这条数据的事务ID。 roll_pointer：指向更新事务发生之前生成的undo log。 undo log版本链undo log版本链 此时事务B也修改了数据，那么更新之前会生成一个undo log，并让新数据的roll_pointer指向这个undo ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://tianmazuo.com/technology/database/mysql/mysql-37.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"添码座"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:tag","content":"MVCC"}],["meta",{"property":"article:published_time","content":"2023-05-07T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MVCC\\",\\"image\\":[\\"https://tianmazuo.com/technology/database/mysql/mysql-37.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-38.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-39.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-40.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-41.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-42.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-43.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-44.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-45.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-46.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-47.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-48.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-49.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-50.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-51.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-52.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-53.png\\"],\\"datePublished\\":\\"2023-05-07T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"添码座\\",\\"url\\":\\"https://www.tianmazuo.com/about/\\"}]}"]]},"headers":[{"level":2,"title":"undo log版本链","slug":"undo-log版本链","link":"#undo-log版本链","children":[]},{"level":2,"title":"ReadView机制","slug":"readview机制","link":"#readview机制","children":[]},{"level":2,"title":"Read Committed隔离级别","slug":"read-committed隔离级别","link":"#read-committed隔离级别","children":[]},{"level":2,"title":"Repeatable Read隔离级别","slug":"repeatable-read隔离级别","link":"#repeatable-read隔离级别","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{},"readingTime":{"minutes":5.42,"words":1626},"filePathRelative":"technology/database/mysql/mvcc.md","localizedDate":"2023年5月7日","excerpt":"<h2>undo log版本链</h2>\\n<p><a href=\\"https://www.mysql.com\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">MySQL</a>中的每条数据其实都有两个隐藏字段。</p>\\n<ul>\\n<li>\\n<p><code>trx_id</code>：最近一次更新这条数据的事务ID。</p>\\n</li>\\n<li>\\n<p><code>roll_pointer</code>：指向更新事务发生之前生成的<code>undo log</code>。</p>\\n</li>\\n</ul>\\n<figure><img src=\\"https://tianmazuo.com/technology/database/mysql/mysql-37.png\\" alt=\\"undo log版本链\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>undo log版本链</figcaption></figure>","autoDesc":true}');export{g as comp,s as data};
