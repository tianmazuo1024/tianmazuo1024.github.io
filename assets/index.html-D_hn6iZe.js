import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,o as a,d as t}from"./app-CiwSPZKD.js";const l={},n=t('<h2 id="与mysql打交道" tabindex="-1"><a class="header-anchor" href="#与mysql打交道"><span>与MySQL打交道</span></a></h2><p>在<a href="https://www.oracle.com/java/technologies/downloads/archive/" target="_blank" rel="noopener noreferrer">Java</a>工程师眼中，<a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>不外乎就是具备建库、建表、建索引，执行增删改查CRUD等功能。同时还会时不时遇到一些小麻烦，例如死锁、报错和事务问题等。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-01.png" alt="Java工程师眼中的数据库" tabindex="0" loading="lazy"><figcaption>Java工程师眼中的数据库</figcaption></figure><p><a href="https://www.oracle.com/java/technologies/downloads/archive/" target="_blank" rel="noopener noreferrer">Java</a>应用在底层与数据库建立网络连接，并通过代码执行<code>SQL</code>查询。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-02.png" alt="通过代码执行SQL查询" tabindex="0" loading="lazy"><figcaption>通过代码执行SQL查询</figcaption></figure><p>但是，通常应用不只有一个连接请求，数据库也不只服务于某个连接。以<a href="https://www.oracle.com/java/technologies/downloads/archive/" target="_blank" rel="noopener noreferrer">Java</a>中的<a href="https://tomcat.apache.org//" target="_blank" rel="noopener noreferrer">Tomcat</a>为例，它会通过多个线程来处理并发请求，达到资源利用的效率最大化。</p><p>如果每处理一个请求就创建一个数据库连接，用完之后再销毁，效率会极其低下，这就好比公交车每上一个人就关一下门，每吃一口饭就洗一次碗。为了解决这种问题，数据库连接池诞生了。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-03.png" alt="分散的数据库连接" tabindex="0" loading="lazy"><figcaption>分散的数据库连接</figcaption></figure><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-04.png" alt="数据库连接池" tabindex="0" loading="lazy"><figcaption>数据库连接池</figcaption></figure><p>连接池的核心任务就是维护与多个系统之间的多个连接。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-05.png" alt="数据库连接池" tabindex="0" loading="lazy"><figcaption>数据库连接池</figcaption></figure><h2 id="mysql架构设计" tabindex="-1"><a class="header-anchor" href="#mysql架构设计"><span>MySQL架构设计</span></a></h2><p><code>SQL</code>语句一般执行的过程如下。</p><ul><li><p>由线程来处理网路哟连接请求（这是不变的前提条件和原则）。</p></li><li><p><code>SQL</code>接口负责处理接收到的SQL语句。</p></li><li><p>查询解析器让<a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>能看懂<code>SQL</code>语句。</p></li><li><p>选择最优的查询路径。</p></li><li><p>调用存储引擎接口，执行<code>SQL</code>查询。</p></li><li><p>根据执行计划调用存储引擎接口。</p></li></ul><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-06.png" alt="SQL语句执行过程" tabindex="0" loading="lazy"><figcaption>SQL语句执行过程</figcaption></figure><div class="hint-container tip"><p class="hint-container-title">问题</p><ul><li><p><a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>有哪些存储引擎？</p></li><li><p>分别适用于什么场景？</p></li></ul></div><h2 id="innodb存储引擎的架构" tabindex="-1"><a class="header-anchor" href="#innodb存储引擎的架构"><span>InnoDB存储引擎的架构</span></a></h2><p>在<a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>中，一条更新语句的执行过程如下。</p><ul><li><p>如果缓冲池内有数据，就不用再去查询磁盘，否则就从磁盘加载，同时加锁。</p></li><li><p>把更新之前的值写入到<code>undo</code>日志文件。</p></li><li><p>更新<code>buffer pool</code>中的缓存数据。</p></li><li><p><code>Redo Log Buffer</code>防止宕机时数据丢失，用来恢复更新过的数据。</p></li><li><p>提交事务时将<code>redo</code>日志写入磁盘。</p><ul><li><p><code>innodb_flush_log_at_trx_commit = 0</code>：提交事务时不把<code>redo log buffer</code>刷入磁盘。</p></li><li><p><code>innodb_flush_log_at_trx_commit = 1</code>：提交事务时必须把<code>redo log buffer</code>刷入磁盘。</p></li><li><p><code>innodb_flush_log_at_trx_commit = 2</code>：提交事务时把<code>redo log buffer</code>刷入<code>os cache</code>。</p></li></ul></li></ul><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-07.png" alt="InnoDB存储引擎的架构" tabindex="0" loading="lazy"><figcaption>InnoDB存储引擎的架构</figcaption></figure><div class="hint-container tip"><p class="hint-container-title">问题</p><ul><li><p>这三种<code>redo</code>日志刷盘策略，应该选择哪一种？</p></li><li><p>每一种刷盘策略的优缺点是什么？为什么？</p></li></ul></div><h2 id="mysql-binlog" tabindex="-1"><a class="header-anchor" href="#mysql-binlog"><span>MySQL binlog</span></a></h2><p><code>binlog</code>是一种归档日志，它不是<code>redo log</code>，但它属于<a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>系统。提交事务时，会同时将提交内容写入<code>binlog</code>。</p><p><code>binlog</code>的刷盘策略如下。</p><ul><li><p><code>sync_binlog = 0</code>：<code>binlog</code>不直接写入磁盘，而是先写到<code>os cache</code>。</p></li><li><p><code>sync_binlog = 1</code>：<code>binlog</code>强制写入到磁盘文件。</p></li></ul><p>当<code>binlog</code>写入磁盘后，会将<code>binlog</code>文件名及更新数据在<code>binlog</code>里的位置<code>offset</code>都写入到<code>redo log</code>，并在<code>redo log</code>中写入一个<code>commit</code>标记，保持两种日志一致。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-08.png" alt="binlog的概念" tabindex="0" loading="lazy"><figcaption>binlog的概念</figcaption></figure><p>总之，<code>InnoDB</code>存储引擎有如下特点。</p><ul><li><p>主要包含一些<code>buffer pool</code>、<code>redo log buffer</code>等缓存数据。</p></li><li><p>同时还包含一些<code>undo</code>日志文件、<code>redo</code>日志文件。</p></li><li><p><code>binlog</code>是属于<a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>系统级别的日志。</p></li><li><p>执行更新时，每条<code>SQL</code>语句都会对应修改<code>buffer pool</code>、<code>redo log buffer</code>、<code>undo</code>日志。</p></li><li><p>提交时，一定会把<code>redo</code>日志、<code>binlog</code>写入磁盘，同时保持<code>redo</code>日志和<code>binlog</code>的一致。</p></li><li><p>最后，后台<code>I/O</code>线程会随机把<code>buffer pool</code>里的脏数据刷入磁盘。</p></li></ul><div class="hint-container tip"><p class="hint-container-title">问题</p><ul><li><p>为什么<a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>在更新数据时，要处理包括<code>buffer pool</code>、<code>undo log</code>、<code>redo log</code>、<code>binlog</code>、事务提交、脏数据、随机刷盘这么多事情？</p></li><li><p>为什么最关键同步磁盘数据，要通过<code>I/O</code>随机刷盘实现？</p></li><li><p>为什么执行完<code>SQL</code>语句不直接更新磁盘数据？</p></li></ul></div>',30),i=[n];function c(r,d){return a(),o("div",null,i)}const g=e(l,[["render",c],["__file","index.html.vue"]]),m=JSON.parse('{"path":"/technology/database/","title":"MySQL初探","lang":"zh-CN","frontmatter":{"title":"MySQL初探","icon":"table","category":["数据库"],"tag":["数据库","MySQL"],"date":"2023-04-30T00:00:00.000Z","isOriginal":true,"star":true,"description":"与MySQL打交道 在Java工程师眼中，MySQL不外乎就是具备建库、建表、建索引，执行增删改查CRUD等功能。同时还会时不时遇到一些小麻烦，例如死锁、报错和事务问题等。 Java工程师眼中的数据库Java工程师眼中的数据库 Java应用在底层与数据库建立网络连接，并通过代码执行SQL查询。 通过代码执行SQL查询通过代码执行SQL查询 但是，通常应...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/technology/database/"}],["meta",{"property":"og:site_name","content":"添码座"}],["meta",{"property":"og:title","content":"MySQL初探"}],["meta",{"property":"og:description","content":"与MySQL打交道 在Java工程师眼中，MySQL不外乎就是具备建库、建表、建索引，执行增删改查CRUD等功能。同时还会时不时遇到一些小麻烦，例如死锁、报错和事务问题等。 Java工程师眼中的数据库Java工程师眼中的数据库 Java应用在底层与数据库建立网络连接，并通过代码执行SQL查询。 通过代码执行SQL查询通过代码执行SQL查询 但是，通常应..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://tianmazuo.com/technology/database/mysql/mysql-01.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"添码座"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:published_time","content":"2023-04-30T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL初探\\",\\"image\\":[\\"https://tianmazuo.com/technology/database/mysql/mysql-01.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-02.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-03.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-04.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-05.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-06.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-07.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-08.png\\"],\\"datePublished\\":\\"2023-04-30T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"添码座\\",\\"url\\":\\"https://www.tianmazuo.com/about/\\"}]}"]]},"headers":[{"level":2,"title":"与MySQL打交道","slug":"与mysql打交道","link":"#与mysql打交道","children":[]},{"level":2,"title":"MySQL架构设计","slug":"mysql架构设计","link":"#mysql架构设计","children":[]},{"level":2,"title":"InnoDB存储引擎的架构","slug":"innodb存储引擎的架构","link":"#innodb存储引擎的架构","children":[]},{"level":2,"title":"MySQL binlog","slug":"mysql-binlog","link":"#mysql-binlog","children":[]}],"git":{},"readingTime":{"minutes":3.47,"words":1040},"filePathRelative":"technology/database/README.md","localizedDate":"2023年4月30日","excerpt":"<h2>与MySQL打交道</h2>\\n<p>在<a href=\\"https://www.oracle.com/java/technologies/downloads/archive/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Java</a>工程师眼中，<a href=\\"https://www.mysql.com\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">MySQL</a>不外乎就是具备建库、建表、建索引，执行增删改查CRUD等功能。同时还会时不时遇到一些小麻烦，例如死锁、报错和事务问题等。</p>\\n<figure><img src=\\"https://tianmazuo.com/technology/database/mysql/mysql-01.png\\" alt=\\"Java工程师眼中的数据库\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>Java工程师眼中的数据库</figcaption></figure>","autoDesc":true}');export{g as comp,m as data};
