import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,o as s,d as a}from"./app-B5m7CcSj.js";const l={},t=a(`<h2 id="什么是buffer-pool" tabindex="-1"><a class="header-anchor" href="#什么是buffer-pool"><span>什么是Buffer Pool</span></a></h2><p>如果数据库直接对磁盘进行随机读写，速度和效率都会很低。因此，引入内存读写缓冲池，也叫<code>Buffer Pool</code>，用来提高<a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>的处理速度和效率。</p><p>执行<code>CRUD</code>时，实际上主要是针对<code>Buffer Pool</code>中的数据进行的，然后再由后台随机<code>I/O</code>线程将<code>Buffer Pool</code>中的数据写入磁盘。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-09.png" alt="Buffer Pool" tabindex="0" loading="lazy"><figcaption>Buffer Pool</figcaption></figure><br><h2 id="buffer-pool的结构" tabindex="-1"><a class="header-anchor" href="#buffer-pool的结构"><span>Buffer Pool的结构</span></a></h2><p><code>Buffer Pool</code>默认大小128M，由<code>innodb_buffer_pool_size</code>参数进行调节。</p><p><a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>抽象出一个数据页的概念，磁盘中包含很多数据页，每个数据页又放了很多行数据，更新一行数据，数据库会找到这行数据所在的数据页，然后加载到<code>Buffer Pool</code>。</p><p>也就是说，<code>Buffer Pool</code>存放的是一个个的数据页。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-10.png" alt="数据页" tabindex="0" loading="lazy"><figcaption>数据页</figcaption></figure><p>数据页又叫缓存页，默认情况下，数据页和缓存页是一一对应的，大小16KB。</p><p>每个缓存页会有一个描述信息，是缓存页的<code>元数据</code>。<code>元数据的大小 ≈ 缓存页大小 × 5%</code>。</p><p>因此，<code>Buffer Pool实际大小 = 128M + 若干元数据</code>。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-11.png" alt="缓存页" tabindex="0" loading="lazy"><figcaption>缓存页</figcaption></figure><div class="hint-container tip"><p class="hint-container-title">问题</p><ul><li><p><code>Buffer Pool</code>会残存内存碎片吗？</p></li><li><p>如果有，该如何尽可能减少内存碎片？</p></li></ul></div><br><h2 id="free链表" tabindex="-1"><a class="header-anchor" href="#free链表"><span>free链表</span></a></h2><p><code>free</code>链表是一个双向链表，每一个节点就是一个空闲缓存页的描述数据块的地址。链表本身就是由描述数据块组成，并没有单独创建一个链表，每个描述数据块都有两个指针：<code>free_pre</code>和<code>free_next</code>。</p><p>数据库启动时，所有的缓存页都是空闲的，因此所有缓存页的描述数据块，都是<code>free</code>链表的节点。</p><p><code>free</code>链表的有一个特殊的节点，叫做基础节点，它不属于<code>Buffer Pool</code>，基础节点会引用<code>free</code>链表的头节点和尾节点，以及链表中有多少个节点（即多少个空闲的缓存页）。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-12.png" alt="free链表" tabindex="0" loading="lazy"><figcaption>free链表</figcaption></figure><p>将数据页读取成缓存页的过程如下。</p><ul><li><p>首先从<code>free</code>链表里得到一个描述数据，就可以得到对应的缓存页。</p></li><li><p>再把磁盘上的数据页读取到对应缓存页中。</p></li><li><p>最后把描述数据块从<code>free</code>链表中删除。</p></li></ul><p>数据库还会有一个哈希表数据结构。</p><ul><li><p><code>key</code>：表空间 + 数据页编码。</p></li><li><p><code>value</code>：缓存页地址。</p></li></ul><p>如果<code>key</code>对应的值为<code>null</code>，则说明该数据页还未被缓存，否则就直接读取。</p><div class="hint-container tip"><p class="hint-container-title">问题</p><ul><li><p><code>表 + 行</code>与<code>表空间 + 数据页</code>这两个概念的区别是什么？</p></li><li><p>它们之间是否存在联系？</p></li></ul></div><br><h2 id="flush链表" tabindex="-1"><a class="header-anchor" href="#flush链表"><span>flush链表</span></a></h2><p>当缓存页和数据页的内容不一致时，就产生了脏数据，也叫脏页。</p><p><code>flush</code>链表同<code>free</code>链表的结构一模一样，只不过<code>flush</code>链表的节点是由被修改过的描述数据块组成的。</p><p>凡是被修改过的缓存页，都会把其描述数据块加入到<code>flush</code>链表，因此flush链表中的缓存页都是脏页，后续都是要写回到磁盘中去的。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-13.png" alt="flush链表" tabindex="0" loading="lazy"><figcaption>flush链表</figcaption></figure><p>基于LRU的缓存页淘汰：</p><ul><li>把脏数据（脏页）写回到磁盘中，然后这个缓存页就清空了；</li><li>再把磁盘上需要的新的数据页加载到这个空闲出来的缓存页中。</li></ul><br><h2 id="lru链表" tabindex="-1"><a class="header-anchor" href="#lru链表"><span>LRU链表</span></a></h2><p>对于高频查询和修改的某个缓存页，可以说它的“命中率”很高。而LRU（Least Recently Used）链表记录哪些缓存页命中率最低。</p><p>只要加载数据，就把缓存页的描述数据块放到LRU的头部去。</p><p>如果缓存页对应的描述数据块在LRU尾部，那么只要查询或者修改了这个缓存页的数据，则其对应的描述数据块就会被挪动到<code>LRU</code>的头部去。</p><p>因此需要被被淘汰的缓存页，都在<code>LRU</code>的尾部，只需要把尾部缓存页数据写入磁盘，再把需要的新数据加载到缓存页中即可，然后再把尾部缓存页移动到<code>LRU</code>头部，就完成了一次缓存页淘汰。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-14.png" alt="LRU链表" tabindex="0" loading="lazy"><figcaption>LRU链表</figcaption></figure><p>当<a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>从磁盘上加载数据时，其预读机制会把该数据页相邻的其它数据页也一并加载进来。这些被“捎带”加载进来的数据页，即使没有被访问，也可能不会被移到<code>LRU</code>的尾部去，会造成巨大的空间浪费。</p><p>触发<a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>预读机制的条件为如下。</p><ul><li><p><code>innodb_read_ahead_threshold</code>，默认65，如果顺序访问同一个区里数据页的数量超过这个阈值，就把下一个相邻区的所有数据页都加载到缓存（区间机制）。</p></li><li><p><code>innodb_random_read_ahead</code>，默认关闭，如果<code>Buffer Pool</code>里缓存了同一个区的13个连续数据页，且命中率都较高，就把该区其它数据页都加载到缓存（区内机制）。</p></li></ul><p>当执行<code>SELECT * FROM TABLE_NAME</code>，会把表中所有的数据页，全部从磁盘加载到<code>Buffer Pool</code>缓存页，造成大量的空间浪费。同时，这种全表扫描也会造成LRU问题。</p><div class="hint-container tip"><p class="hint-container-title">问题</p><ul><li><p>为什么<a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>有预读机制？</p></li><li><p>为什么要加载相邻数据页？有什么意义？</p></li><li><p>在什么场景下这样做很有用？</p></li></ul></div><br><h2 id="冷热分离" tabindex="-1"><a class="header-anchor" href="#冷热分离"><span>冷热分离</span></a></h2><p>由于预读机制，导致一些无用的缓存页也混在LRU链表里。因此<a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>采取了冷热分离的设计思想。</p><ul><li><p>一部分是热数据<code>LRU</code>。</p></li><li><p>一部分是冷数据<code>LRU</code>。</p></li><li><p><code>冷热</code>比例由<code>innodb_old_blocks_pct</code>控制，默认冷数据占<code>37%</code>。</p></li></ul><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-15.png" alt="冷热LRU" tabindex="0" loading="lazy"><figcaption>冷热LRU</figcaption></figure><p>冷热分离的运行机制如下。</p><ul><li><p>第一次加载数据的缓存页，会被放在冷数据区域的链表头部。</p></li><li><p>经过<code>innodb_old_blocks_time</code>（默认值1000ms）所指定的时间之后，再访问缓存页时，才会将这个缓存页移动到热数据区域的头部。</p></li></ul><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-16.png" alt="运行机制" tabindex="0" loading="lazy"><figcaption>运行机制</figcaption></figure><p>预读机制及全表扫描加载进来的一大堆缓存页，都放在冷数据区域的头部，不会对热数据区域造成影响。加载到冷数据区域的缓存页，1s之后如果被访问了，就移动到热数据区域的头部，如果缓存页不够，需要淘汰一些缓存，就直接找到冷数据区域的尾部，写入磁盘，并加载新数据。</p><p><a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>对<code>LRU</code>热数据区域的优化机制是：只有当缓存页位于热数据区域后部3/4时，才会被移动到链表头部。设计缓存机制时，可以借鉴冷热数据分离的思想，如<a href="https://www.redis.io/" target="_blank" rel="noopener noreferrer">Redis</a>。</p><br><h2 id="缓存页" tabindex="-1"><a class="header-anchor" href="#缓存页"><span>缓存页</span></a></h2><ul><li><p><code>Buffer Pool</code>中有若干缓存页，每个缓存页都有对应的描述文件，在<a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>加载数据前，由free链表统一管理这些缓存页。</p></li><li><p>当从磁盘加载数据到内存时，<code>free</code>链表会移除被使用的缓存页，同时<code>LRU</code>链表的冷数据区域会放入这个缓存页。</p></li><li><p>如果这个缓存页被修改，那么<code>flush</code>链表会记录这个脏页，如果修改时间在缓存页加载完毕1s之后，那么这个缓存页还会被<code>LRU</code>链表从冷数据区域移动到热数据区域的头部。</p></li><li><p>如果这个缓存页本身就位于热数据区域，并且如果是位于链表位置的3/4部位，那么也会被移动到热数据区域的头部。</p></li><li><p>如果缓存页空间不足，那么会直接将<code>LRU</code>冷数据区域尾部的缓存页数据写入磁盘，然后腾出空间来存放新数据。</p></li></ul><p>除了空间不足，其他将缓存页写入磁盘的时机如下。</p><ul><li><p>后台线程定时将LRU冷数据区域尾部的一些缓存页数据刷入磁盘，并把它们加回<code>free</code>链表，也一并从<code>flush</code>链表和<code>LRU</code>链表移除。</p></li><li><p>后台线程会不定时把<code>flush</code>链表中的一些缓存页刷入磁盘，并把它们加回<code>free</code>链表，也一并从<code>flush</code>链表和<code>LRU</code>链表移除。</p></li></ul><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-17.png" alt="缓存页刷盘时机" tabindex="0" loading="lazy"><figcaption>缓存页刷盘时机</figcaption></figure><div class="hint-container tip"><p class="hint-container-title">问题</p><ul><li>该优化哪些<a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>内核参数，才能尽可能避免缓存页经常出现空间不足的情况？</li></ul></div><br><h2 id="推荐做法" tabindex="-1"><a class="header-anchor" href="#推荐做法"><span>推荐做法</span></a></h2><h3 id="buffer-pool的问题" tabindex="-1"><a class="header-anchor" href="#buffer-pool的问题"><span>Buffer Pool的问题</span></a></h3><p>多线程并发访问<code>Buffer Pool</code>时，必然要进行加锁，非常影响性能。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-18.png" alt="多线程并发访问Buffer Pool" tabindex="0" loading="lazy"><figcaption>多线程并发访问Buffer Pool</figcaption></figure><p>如果给<code>Buffer Pool</code>分配的内存空间 ＜ 1GB，那么最多只有一个<code>Buffer Pool</code>。因此，可以通过适当调整<a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>内核参数来提升<code>Buffer Pool</code>的处理效率。</p><ul><li><p>innodb_buffer_pool_size = 8589934592</p></li><li><p>innodb_buffer_pool_instance = 4</p></li></ul><p>给<code>Buffer Pool</code>分配了8GB内存空间，设置了4个实例，每个<code>Buffer Pool</code> = 2GB。</p><p>因此在实际生产环境中，<code>Buffer Pool</code>的大小、数量、机器配置，都会对系统性能造成直接的影响，这需要通过不断压测来达到一个动态的平衡。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-19.png" alt="多个Buffer Pool" tabindex="0" loading="lazy"><figcaption>多个Buffer Pool</figcaption></figure><h3 id="chunk机制" tabindex="-1"><a class="header-anchor" href="#chunk机制"><span>chunk机制</span></a></h3><p>如果<code>Buffer Pool</code>初始化的大小被固定死，是无法动态调整的。<a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>为此设计了<code>chunk</code>机制：由很多<code>chunk</code>来拼成<code>Buffer Pool</code>。</p><ul><li><p>通过<code>innodb_buffer_pool_chunk_size</code>控制每个<code>chunk</code>大小，默认值128MB。</p></li><li><p>每个<code>chunk</code>里都包含缓存页、描述数据块，但共享<code>free</code>链表、<code>flush</code>链表、<code>LRU</code>链表等数据结构。</p></li></ul><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-20.png" alt="chunk机制" tabindex="0" loading="lazy"><figcaption>chunk机制</figcaption></figure><h3 id="buffer-pool大小设置" tabindex="-1"><a class="header-anchor" href="#buffer-pool大小设置"><span>Buffer Pool大小设置</span></a></h3><ul><li><p><code>Buffer Pool</code>大小一般为机器物理内存的50%~60%。</p></li><li><p><code>Buffer Pool</code>总大小 = (chunk大小 × Buffer Pool数量) × 整数倍，可以据此来确定每个chunk的大小及Buffer Pool数量。</p><ul><li><p>内存32G，chunk=128M，Buffer Pool=20G，Buffer Pool数量=10 20倍 √</p></li><li><p>内存32G，chunk=128M，Buffer Pool=20G，Buffer Pool数量=32 5倍 √</p></li><li><p>内存32G，chunk=640M，Buffer Pool=20G，Buffer Pool数量=8 4倍 √</p></li><li><p>内存32G，chunk=128M，Buffer Pool=20G，Buffer Pool数量=256 小数倍 ×</p></li></ul></li></ul><br><h2 id="查看innodb引擎状态" tabindex="-1"><a class="header-anchor" href="#查看innodb引擎状态"><span>查看innodb引擎状态</span></a></h2><p>数据库启动后，可以通过<code>show engine innodb status</code>查看<code>innodb</code>引擎中关于<code>Buffer Pool</code>的状态数据。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> show engine innodb </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">status</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">----------------------</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">BUFFER</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> POOL</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> AND</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> MEMORY</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">----------------------</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Total large memory allocated </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">8585216</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Dictionary memory allocated </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">314658</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">Buffer</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> pool</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> size</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">   512</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Free buffers       </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">254</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">Database</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> pages     </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">256</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Old </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">database</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> pages </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Modified db pages  </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Pending reads      </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Pending writes: LRU </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, flush list </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, single </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">page</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Pages made young </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">not</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> young </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">00</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> youngs/s, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">00</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> non-youngs/s</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Pages </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">read</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 427</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, created </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">58</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, written </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">91</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">29</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> reads/s, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">00</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> creates/s, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">94</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> writes/s</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">Buffer</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> pool</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> hit rate </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">978</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> / </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, young-making rate </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> / </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1000</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> not</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> / </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1000</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">Pages </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">read</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ahead </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">00</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">/s, evicted </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">without</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> access </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">00</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">/s, Random </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">read</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ahead </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">00</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">/s</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">LRU len: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">256</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, unzip_LRU len: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">I/O sum</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[96]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:cur</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[3]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, unzip sum</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[0]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:cur</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[0]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th style="text-align:center;">参数</th><th style="text-align:left;">含义</th></tr></thead><tbody><tr><td style="text-align:center;">Total large memory allocated</td><td style="text-align:left;">Buffer Pool总大小</td></tr><tr><td style="text-align:center;">Buffer pool size</td><td style="text-align:left;">Buffer Pool一功能容纳多少个缓存页</td></tr><tr><td style="text-align:center;">Free buffers</td><td style="text-align:left;">free链表中共有多少可用空闲缓存页</td></tr><tr><td style="text-align:center;">Database pages和Old database pages</td><td style="text-align:left;">LRU链表中共有多少缓存页，及冷数据区缓存页的数量</td></tr><tr><td style="text-align:center;">Modified db pages</td><td style="text-align:left;">flush链表中缓存页数量</td></tr><tr><td style="text-align:center;">Pending reads和Pending writes</td><td style="text-align:left;">等待从磁盘加载进缓存页的数量，以及即将从LRU链表和flush链表中刷入磁盘的数量</td></tr><tr><td style="text-align:center;">Pages made young和not young</td><td style="text-align:left;">LRU冷数据区域转移到热数据区域的缓存页的数量，以及在LRU冷数据区1s内被访问且没有进热数据区域的缓存页的数量</td></tr><tr><td style="text-align:center;">Pending reads和Pending writes</td><td style="text-align:left;">每秒从冷数据区域进入热数据区域的缓存页的数量，以及每秒在冷数据区域里被访问了但不能进入热数据区域的缓存页的数量</td></tr><tr><td style="text-align:center;">Pages read、created、written、</td><td style="text-align:left;"></td></tr><tr><td style="text-align:center;">reads/s、creates/s和writes/s</td><td style="text-align:left;">已经读取、创建和写入的缓存页数量，以及每秒读取、创建和写入的缓存页数量</td></tr><tr><td style="text-align:center;">Buffer pool hit rate xxx / 1000</td><td style="text-align:left;">每1000次访问，有多少次是直接命中buffer pool里的缓存页的</td></tr><tr><td style="text-align:center;">young-making rate xxx / 1000和not</td><td style="text-align:left;">每1000次访问，有多少次让缓存页从冷数据区域移到了热数据区域，以及没移动的缓存页数量</td></tr><tr><td style="text-align:center;">LRU len</td><td style="text-align:left;">LRU链表里缓存页的数量</td></tr><tr><td style="text-align:center;">I/O sum</td><td style="text-align:left;">最近50s读取磁盘数据页的总数</td></tr></tbody></table><div class="hint-container tip"><p class="hint-container-title">问题</p><ul><li>针对手头的<a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>执行状态查询命令，分析数据库<code>buffer pool</code>的使用情况。</li></ul></div>`,86),n=[t];function o(p,r){return s(),i("div",null,n)}const c=e(l,[["render",o],["__file","bufferpool.html.vue"]]),k=JSON.parse('{"path":"/technology/database/mysql/bufferpool.html","title":"Buffer Pool","lang":"zh-CN","frontmatter":{"title":"Buffer Pool","icon":"table","category":["数据库","MySQL"],"tag":["数据库","MySQL"],"date":"2023-05-04T00:00:00.000Z","isOriginal":true,"star":true,"description":"什么是Buffer Pool 如果数据库直接对磁盘进行随机读写，速度和效率都会很低。因此，引入内存读写缓冲池，也叫Buffer Pool，用来提高MySQL的处理速度和效率。 执行CRUD时，实际上主要是针对Buffer Pool中的数据进行的，然后再由后台随机I/O线程将Buffer Pool中的数据写入磁盘。 Buffer PoolBuffer P...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/technology/database/mysql/bufferpool.html"}],["meta",{"property":"og:site_name","content":"添码座"}],["meta",{"property":"og:title","content":"Buffer Pool"}],["meta",{"property":"og:description","content":"什么是Buffer Pool 如果数据库直接对磁盘进行随机读写，速度和效率都会很低。因此，引入内存读写缓冲池，也叫Buffer Pool，用来提高MySQL的处理速度和效率。 执行CRUD时，实际上主要是针对Buffer Pool中的数据进行的，然后再由后台随机I/O线程将Buffer Pool中的数据写入磁盘。 Buffer PoolBuffer P..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://tianmazuo.com/technology/database/mysql/mysql-09.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"添码座"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:published_time","content":"2023-05-04T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Buffer Pool\\",\\"image\\":[\\"https://tianmazuo.com/technology/database/mysql/mysql-09.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-10.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-11.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-12.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-13.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-14.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-15.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-16.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-17.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-18.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-19.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-20.png\\"],\\"datePublished\\":\\"2023-05-04T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"添码座\\",\\"url\\":\\"https://www.tianmazuo.com/about/\\"}]}"]]},"headers":[{"level":2,"title":"什么是Buffer Pool","slug":"什么是buffer-pool","link":"#什么是buffer-pool","children":[]},{"level":2,"title":"Buffer Pool的结构","slug":"buffer-pool的结构","link":"#buffer-pool的结构","children":[]},{"level":2,"title":"free链表","slug":"free链表","link":"#free链表","children":[]},{"level":2,"title":"flush链表","slug":"flush链表","link":"#flush链表","children":[]},{"level":2,"title":"LRU链表","slug":"lru链表","link":"#lru链表","children":[]},{"level":2,"title":"冷热分离","slug":"冷热分离","link":"#冷热分离","children":[]},{"level":2,"title":"缓存页","slug":"缓存页","link":"#缓存页","children":[]},{"level":2,"title":"推荐做法","slug":"推荐做法","link":"#推荐做法","children":[{"level":3,"title":"Buffer Pool的问题","slug":"buffer-pool的问题","link":"#buffer-pool的问题","children":[]},{"level":3,"title":"chunk机制","slug":"chunk机制","link":"#chunk机制","children":[]},{"level":3,"title":"Buffer Pool大小设置","slug":"buffer-pool大小设置","link":"#buffer-pool大小设置","children":[]}]},{"level":2,"title":"查看innodb引擎状态","slug":"查看innodb引擎状态","link":"#查看innodb引擎状态","children":[]}],"git":{},"readingTime":{"minutes":10.41,"words":3123},"filePathRelative":"technology/database/mysql/bufferpool.md","localizedDate":"2023年5月4日","excerpt":"<h2>什么是Buffer Pool</h2>\\n<p>如果数据库直接对磁盘进行随机读写，速度和效率都会很低。因此，引入内存读写缓冲池，也叫<code>Buffer Pool</code>，用来提高<a href=\\"https://www.mysql.com\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">MySQL</a>的处理速度和效率。</p>\\n<p>执行<code>CRUD</code>时，实际上主要是针对<code>Buffer Pool</code>中的数据进行的，然后再由后台随机<code>I/O</code>线程将<code>Buffer Pool</code>中的数据写入磁盘。</p>","autoDesc":true}');export{c as comp,k as data};
