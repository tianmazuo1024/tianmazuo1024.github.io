import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,o as l,d}from"./app-CiwSPZKD.js";const n={},a=d('<h2 id="事务并发问题" tabindex="-1"><a class="header-anchor" href="#事务并发问题"><span>事务并发问题</span></a></h2><h3 id="多事务执行问题" tabindex="-1"><a class="header-anchor" href="#多事务执行问题"><span>多事务执行问题</span></a></h3><p>业务系统并不是单线程运行，而是需要多个线程来同时响应多个用户同时发起的请求。每个线程中的事务，都会执行从磁盘加载数据页到内存缓存页，再由后台<code>I/O</code>进程写回磁盘的过程，这需要解决几个问题。</p><ul><li><p>如果多个事务同时对某一个缓存页里的数据进行更新，如何处理冲突？</p></li><li><p>一个事务在更新，另一个事务在查询，如何处理冲突？</p></li></ul><p><a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>只有<code>InnoDB</code>引擎支持事务。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-31.png" alt="多事务执行" tabindex="0" loading="lazy"><figcaption>多事务执行</figcaption></figure><h3 id="脏写-第一类丢失更新" tabindex="-1"><a class="header-anchor" href="#脏写-第一类丢失更新"><span>脏写（第一类丢失更新）</span></a></h3><p><code>脏写</code>的定义是：<code>事务A</code>和<code>事务B</code>修改了同一个值，一个完成提交，一个异常回滚。不管哪个事务回滚，另一个事务所更新的数据就会丢失，这就是<code>脏写</code>。</p><ul><li><p><code>事务A</code>和<code>事务B</code>同时更新某条数据X，<code>事务A</code>将之更新为Y。</p></li><li><p><code>事务A</code>更新后但未提交，<code>事务B</code>紧接着更新为Z（<code>事务B</code>提交或未提交不影响结果）。</p></li><li><p><code>事务A</code>异常回滚，则该行数据恢复到X，造成<code>事务B</code>更新的数据Z丢失。</p></li></ul><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-32.png" alt="脏写" tabindex="0" loading="lazy"><figcaption>脏写</figcaption></figure><p>经典的<code>脏写</code>案例。</p><table><thead><tr><th style="text-align:center;">时序</th><th style="text-align:center;">存款事务</th><th style="text-align:center;">取款事务</th></tr></thead><tbody><tr><td style="text-align:center;">T1</td><td style="text-align:center;">查询账户余额1000</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">T2</td><td style="text-align:center;"></td><td style="text-align:center;">查询账户余额1000</td></tr><tr><td style="text-align:center;">T3</td><td style="text-align:center;"></td><td style="text-align:center;">开始事务</td></tr><tr><td style="text-align:center;">T4</td><td style="text-align:center;">开始事务</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">T5</td><td style="text-align:center;">存入100元</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">T6</td><td style="text-align:center;">改余额为1100</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">T7</td><td style="text-align:center;"></td><td style="text-align:center;">取出100</td></tr><tr><td style="text-align:center;">T8</td><td style="text-align:center;"></td><td style="text-align:center;">改余额为900</td></tr><tr><td style="text-align:center;">T9</td><td style="text-align:center;"></td><td style="text-align:center;">提交事务</td></tr><tr><td style="text-align:center;">T10</td><td style="text-align:center;">事务回滚</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">T11</td><td style="text-align:center;">undo log，账户余额回滚到1000</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">T12</td><td style="text-align:center;"></td><td style="text-align:center;">查询账户余额1000（数据900丢失）</td></tr></tbody></table><h3 id="丢失更新-第二类丢失更新" tabindex="-1"><a class="header-anchor" href="#丢失更新-第二类丢失更新"><span>丢失更新（第二类丢失更新）</span></a></h3><p><code>丢失更新</code>的定义是：两个事务并发更新同一条数据记录，后完成的事务造成先完成的事务更新丢失了。</p><ul><li><p><code>事务A</code>和<code>事务B</code>查询得到数据X。</p></li><li><p><code>事务A</code>提交并更新，结果变为Y。</p></li><li><p><code>事务B</code>提交并更新，结果变为Z。</p></li><li><p><code>事务A</code>的更新丢失了。</p></li></ul><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-33.png" alt="丢失更新" tabindex="0" loading="lazy"><figcaption>丢失更新</figcaption></figure><p>经典的<code>丢失更新</code>案例。</p><table><thead><tr><th style="text-align:center;">时序</th><th style="text-align:center;">存款事务</th><th style="text-align:center;">取款事务</th></tr></thead><tbody><tr><td style="text-align:center;">T1</td><td style="text-align:center;">查询账户余额1000</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">T2</td><td style="text-align:center;"></td><td style="text-align:center;">查询账户余额1000</td></tr><tr><td style="text-align:center;">T3</td><td style="text-align:center;"></td><td style="text-align:center;">开始事务</td></tr><tr><td style="text-align:center;">T4</td><td style="text-align:center;">开始事务</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">T5</td><td style="text-align:center;">存入100元</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">T6</td><td style="text-align:center;">改余额为1100</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">T7</td><td style="text-align:center;">提交事务</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">T8</td><td style="text-align:center;"></td><td style="text-align:center;">取出100</td></tr><tr><td style="text-align:center;">T9</td><td style="text-align:center;"></td><td style="text-align:center;">改余额为900</td></tr><tr><td style="text-align:center;">T10</td><td style="text-align:center;">提交事务</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">T11</td><td style="text-align:center;">查询账户余额900（数据1100丢失）</td><td style="text-align:center;"></td></tr></tbody></table><h3 id="脏读" tabindex="-1"><a class="header-anchor" href="#脏读"><span>脏读</span></a></h3><p><code>脏读</code>的定义是：<code>事务B</code>查询了<code>事务A</code>修改过的值，但此时<code>事务A</code>还未提交。当<code>事务A</code>回滚后，<code>事务B</code>就无法再次查询到刚才修改过的数据，这就是<code>脏读</code>。</p><ul><li><p><code>事务A</code>更新了某行数据X，更新后的数据为Y，但<code>事务A</code>还未提交。</p></li><li><p><code>事务B</code>查询到该行数据的值为Y并进行业务处理。</p></li><li><p><code>事务A</code>异常回滚，当<code>事务B</code>再次查询该行数据时，发现值变成了X，发生了脏读。</p></li></ul><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-34.png" alt="脏读" tabindex="0" loading="lazy"><figcaption>脏读</figcaption></figure><p>经典的<code>脏读</code>案例。</p><table><thead><tr><th style="text-align:center;">时序</th><th style="text-align:center;">存款事务</th><th style="text-align:center;">取款事务</th></tr></thead><tbody><tr><td style="text-align:center;">T1</td><td style="text-align:center;">查询账户余额1000</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">T2</td><td style="text-align:center;">开始事务</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">T3</td><td style="text-align:center;">存入100元</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">T4</td><td style="text-align:center;">改余额为1100</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">T5</td><td style="text-align:center;"></td><td style="text-align:center;">查询账户余额1100（脏读数据）</td></tr><tr><td style="text-align:center;">T6</td><td style="text-align:center;">回滚事务</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">T7</td><td style="text-align:center;">账户余额恢复为1000</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">T8</td><td style="text-align:center;"></td><td style="text-align:center;">查询账户余额1000</td></tr></tbody></table><h3 id="不可重复读" tabindex="-1"><a class="header-anchor" href="#不可重复读"><span>不可重复读</span></a></h3><p><code>不可重复读</code>的的定义是：同一个事务在多次查询相同数据的时候，得到的数值不同。</p><ul><li><p><code>事务A</code>、<code>事务B</code>和事务C同时处理某一行数据X，<code>事务A</code>第一次查询，得到数据值X。</p></li><li><p><code>事务B</code>修改该行数据值为B并提交，<code>事务A</code>再次查询该行，得到数据值Y。</p></li><li><p>事务C修改该行数据值为C并提交，<code>事务A</code>再次查询该行，得到数据值Z。</p></li><li><p><code>事务A</code>希望多次查询得到的都是同一个值，即数据值是可以重复读的。</p></li><li><p>但经过其他事务的修改并提交后，<code>事务A</code>得到数据明显是不可重复读的。</p></li></ul><p>另外，<strong><mark>不可重复读取决于具体场景，如果允许它存在，那就不是问题。</mark></strong></p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-35.png" alt="不可重复读" tabindex="0" loading="lazy"><figcaption>不可重复读</figcaption></figure><p>经典的<code>不可重复读</code>案例。</p><table><thead><tr><th style="text-align:center;">时序</th><th style="text-align:center;">存款事务</th><th style="text-align:center;">取款事务</th><th style="text-align:center;">转账事务</th></tr></thead><tbody><tr><td style="text-align:center;">T1</td><td style="text-align:center;">查询账户余额1000</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">T2</td><td style="text-align:center;"></td><td style="text-align:center;">开始事务</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">T3</td><td style="text-align:center;"></td><td style="text-align:center;">存入100元</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">T4</td><td style="text-align:center;"></td><td style="text-align:center;">改余额为1100</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">T5</td><td style="text-align:center;"></td><td style="text-align:center;">提交事务</td><td style="text-align:center;">开始事务</td></tr><tr><td style="text-align:center;">T6</td><td style="text-align:center;">查询账户余额1100</td><td style="text-align:center;"></td><td style="text-align:center;">汇入100元</td></tr><tr><td style="text-align:center;">T7</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">改余额为1200</td></tr><tr><td style="text-align:center;">T8</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">提交事务</td></tr><tr><td style="text-align:center;">T9</td><td style="text-align:center;">查询账户余额1200</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr></tbody></table><h3 id="幻读" tabindex="-1"><a class="header-anchor" href="#幻读"><span>幻读</span></a></h3><p><code>幻读</code>的定义是：同一个事务用相同的<code>SQL</code>多次查询，每次查询出来的数据都比上次多一些。</p><ul><li><p><code>事务A</code>按条件查询，得到10条数据。</p></li><li><p><code>事务B</code>插入数据并提交。</p></li><li><p><code>事务A</code>按相同条件查询，得到多于10条的数据，多出来的数据就是幻读。</p></li></ul><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-36.png" alt="幻读" tabindex="0" loading="lazy"><figcaption>幻读</figcaption></figure><p>经典的<code>幻读</code>案例。</p><table><thead><tr><th style="text-align:center;">时序</th><th style="text-align:center;">查账事务</th><th style="text-align:center;">还款事务</th></tr></thead><tbody><tr><td style="text-align:center;">T1</td><td style="text-align:center;">查询到已还款账户10个</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">T2</td><td style="text-align:center;"></td><td style="text-align:center;">开始事务</td></tr><tr><td style="text-align:center;">T3</td><td style="text-align:center;"></td><td style="text-align:center;">批量更改账户状态</td></tr><tr><td style="text-align:center;">T4</td><td style="text-align:center;"></td><td style="text-align:center;">提交事务</td></tr><tr><td style="text-align:center;">T5</td><td style="text-align:center;">查询到已还款账户15个</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">T6</td><td style="text-align:center;"></td><td style="text-align:center;">开始事务</td></tr><tr><td style="text-align:center;">T7</td><td style="text-align:center;"></td><td style="text-align:center;">批量更改账户状态</td></tr><tr><td style="text-align:center;">T8</td><td style="text-align:center;"></td><td style="text-align:center;">提交事务</td></tr><tr><td style="text-align:center;">T9</td><td style="text-align:center;">查询到已还款账户30个</td><td style="text-align:center;"></td></tr></tbody></table><h3 id="联系与区别" tabindex="-1"><a class="header-anchor" href="#联系与区别"><span>联系与区别</span></a></h3><ul><li><p><code>脏写</code>为<code>第一类丢失更新</code>，并发更新同一数据记录时，因<code>事务A</code>回滚，造成<code>事务B</code>无法从<code>undo log</code>里恢复数据。</p></li><li><p><code>丢失更新</code>为<code>第二类丢失更新</code>，并发更新同一数据记录时，后完成的事务数据覆盖了先完成的事务数据。</p></li><li><p><code>脏读</code>针对的是两个事务：<code>事务B</code>读取了<code>事务A</code>未提交的数据。</p></li><li><p><code>不可重复读</code>仅针对单个事务：<code>事务A</code>每次读出的记录值不同，重点在于<code>update</code>和<code>delete</code>，针对单条记录值。</p></li><li><p><code>幻读</code>仅针对单个事务：<code>事务A</code>每次查询的记录数不同，重点在于<code>insert</code>，针对多条记录值。</p></li></ul><br><h2 id="事务隔离机制" tabindex="-1"><a class="header-anchor" href="#事务隔离机制"><span>事务隔离机制</span></a></h2><h3 id="标准的隔离级别" tabindex="-1"><a class="header-anchor" href="#标准的隔离级别"><span>标准的隔离级别</span></a></h3><ul><li><p><code>读未提交（Read Uncommitted，简写RU）</code>：一个事务可以读取另一个事务未提交的数据，不允许出现<code>脏写</code>，但会出现<code>脏读</code>、<code>不可重复读</code>和<code>幻读</code>的事务并发问题，事务性最差，但性能最强。</p></li><li><p><code>读已提交（Read Committed，简写RC）</code>：一个事务只能读取另一个事务已经提交的数据，避免了<code>脏写</code>和<code>脏读</code>，但性能比<code>读未提交</code>差。</p></li><li><p><code>可重复读（Repeatable Read，简写RR）</code>：同一个事务多次读取同一条数据，返回的结果是一样的，避免了<code>脏写</code>、<code>丢失更新</code>、<code>脏读</code>和<code>不可重复读</code>，性能比读已提交差。</p></li><li><p><code>串行化（Serializable，简写S）</code>：所有事务串行执行，避免了所有的事务并发问题，性能最差。</p></li></ul><h3 id="隔离级别与并发问题对应" tabindex="-1"><a class="header-anchor" href="#隔离级别与并发问题对应"><span>隔离级别与并发问题对应</span></a></h3><table><thead><tr><th style="text-align:center;">隔离级别</th><th style="text-align:center;">脏写</th><th style="text-align:center;">丢失更新</th><th style="text-align:center;">脏读</th><th style="text-align:center;">不可重复读</th><th style="text-align:center;">幻读</th></tr></thead><tbody><tr><td style="text-align:center;">读未提交RU</td><td style="text-align:center;">√</td><td style="text-align:center;">×</td><td style="text-align:center;">×</td><td style="text-align:center;">×</td><td style="text-align:center;">×</td></tr><tr><td style="text-align:center;">读已提交RC</td><td style="text-align:center;">√</td><td style="text-align:center;">×</td><td style="text-align:center;">√</td><td style="text-align:center;">×</td><td style="text-align:center;">×</td></tr><tr><td style="text-align:center;">可重复读RR</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td><td style="text-align:center;">×</td></tr><tr><td style="text-align:center;">串行化SER</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td></tr></tbody></table><h3 id="mysql事务隔离级别" tabindex="-1"><a class="header-anchor" href="#mysql事务隔离级别"><span>MySQL事务隔离级别</span></a></h3><p>虽然<a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>默认的事务隔离级别是<code>可重复读（Repeatable Read）</code>，但跟标准的<code>SQL</code>事务隔离级别还有些不同，因为<a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>的<code>RR事务隔离级别</code>把<code>幻读</code>也避免了。</p><p>这都是得益于<a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>的<code>MVCC</code>（Multi-Version Concurrency Control，多版本并发控制）机制。</p><p>可以通过命令修改<a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>默认的事务隔离级别。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> SET</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> [GLOBAL|SESSION]</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> TRANSACTION</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> ISOLATION</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> LEVEL</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> level</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在<a href="https://www.spring.io/" target="_blank" rel="noopener noreferrer">Spring</a>的<code>@Transactional</code>注解中，可以通过<code>isolation</code>参数设置隔离级别，<code>@Transactional(isolation = Isolation.DEFAULT)</code>的可选值如下。</p><ul><li><p><code>Isolation.READ_UNCOMMITTED</code>。</p></li><li><p><code>Isolation.READ_COMMITTED</code>。</p></li><li><p><code>Isolation.REPEATABLE_READ</code>。</p></li><li><p><code>Isolation.SERIALIZABLE</code>。</p></li></ul>',52),c=[a];function r(i,s){return l(),e("div",null,c)}const y=t(n,[["render",r],["__file","transaction.html.vue"]]),p=JSON.parse('{"path":"/technology/database/mysql/transaction.html","title":"事务与隔离级别","lang":"zh-CN","frontmatter":{"title":"事务与隔离级别","icon":"table","category":["数据库","MySQL"],"tag":["数据库","MySQL"],"date":"2023-05-06T00:00:00.000Z","isOriginal":true,"star":true,"description":"事务并发问题 多事务执行问题 业务系统并不是单线程运行，而是需要多个线程来同时响应多个用户同时发起的请求。每个线程中的事务，都会执行从磁盘加载数据页到内存缓存页，再由后台I/O进程写回磁盘的过程，这需要解决几个问题。 如果多个事务同时对某一个缓存页里的数据进行更新，如何处理冲突？ 一个事务在更新，另一个事务在查询，如何处理冲突？ MySQL只有Inno...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/technology/database/mysql/transaction.html"}],["meta",{"property":"og:site_name","content":"添码座"}],["meta",{"property":"og:title","content":"事务与隔离级别"}],["meta",{"property":"og:description","content":"事务并发问题 多事务执行问题 业务系统并不是单线程运行，而是需要多个线程来同时响应多个用户同时发起的请求。每个线程中的事务，都会执行从磁盘加载数据页到内存缓存页，再由后台I/O进程写回磁盘的过程，这需要解决几个问题。 如果多个事务同时对某一个缓存页里的数据进行更新，如何处理冲突？ 一个事务在更新，另一个事务在查询，如何处理冲突？ MySQL只有Inno..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://tianmazuo.com/technology/database/mysql/mysql-31.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"添码座"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:published_time","content":"2023-05-06T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"事务与隔离级别\\",\\"image\\":[\\"https://tianmazuo.com/technology/database/mysql/mysql-31.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-32.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-33.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-34.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-35.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-36.png\\"],\\"datePublished\\":\\"2023-05-06T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"添码座\\",\\"url\\":\\"https://www.tianmazuo.com/about/\\"}]}"]]},"headers":[{"level":2,"title":"事务并发问题","slug":"事务并发问题","link":"#事务并发问题","children":[{"level":3,"title":"多事务执行问题","slug":"多事务执行问题","link":"#多事务执行问题","children":[]},{"level":3,"title":"脏写（第一类丢失更新）","slug":"脏写-第一类丢失更新","link":"#脏写-第一类丢失更新","children":[]},{"level":3,"title":"丢失更新（第二类丢失更新）","slug":"丢失更新-第二类丢失更新","link":"#丢失更新-第二类丢失更新","children":[]},{"level":3,"title":"脏读","slug":"脏读","link":"#脏读","children":[]},{"level":3,"title":"不可重复读","slug":"不可重复读","link":"#不可重复读","children":[]},{"level":3,"title":"幻读","slug":"幻读","link":"#幻读","children":[]},{"level":3,"title":"联系与区别","slug":"联系与区别","link":"#联系与区别","children":[]}]},{"level":2,"title":"事务隔离机制","slug":"事务隔离机制","link":"#事务隔离机制","children":[{"level":3,"title":"标准的隔离级别","slug":"标准的隔离级别","link":"#标准的隔离级别","children":[]},{"level":3,"title":"隔离级别与并发问题对应","slug":"隔离级别与并发问题对应","link":"#隔离级别与并发问题对应","children":[]},{"level":3,"title":"MySQL事务隔离级别","slug":"mysql事务隔离级别","link":"#mysql事务隔离级别","children":[]}]}],"git":{},"readingTime":{"minutes":6.62,"words":1986},"filePathRelative":"technology/database/mysql/transaction.md","localizedDate":"2023年5月6日","excerpt":"<h2>事务并发问题</h2>\\n<h3>多事务执行问题</h3>\\n<p>业务系统并不是单线程运行，而是需要多个线程来同时响应多个用户同时发起的请求。每个线程中的事务，都会执行从磁盘加载数据页到内存缓存页，再由后台<code>I/O</code>进程写回磁盘的过程，这需要解决几个问题。</p>\\n<ul>\\n<li>\\n<p>如果多个事务同时对某一个缓存页里的数据进行更新，如何处理冲突？</p>\\n</li>\\n<li>\\n<p>一个事务在更新，另一个事务在查询，如何处理冲突？</p>\\n</li>\\n</ul>\\n<p><a href=\\"https://www.mysql.com\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">MySQL</a>只有<code>InnoDB</code>引擎支持事务。</p>","autoDesc":true}');export{y as comp,p as data};
