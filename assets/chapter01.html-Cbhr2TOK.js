import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,o as t,d as r}from"./app-B5m7CcSj.js";const i={},a=r('<h2 id="统治地球的冯·诺依曼们" tabindex="-1"><a class="header-anchor" href="#统治地球的冯·诺依曼们"><span>统治地球的冯·诺依曼们</span></a></h2><p>1961年，一个叫<a href="https://zh.wikipedia.org/wiki/%E5%8F%B6%E6%B0%B8%E7%83%88" target="_blank" rel="noopener noreferrer">叶永烈</a>的21岁青年（他也是<a href="https://zh.wikipedia.org/wiki/%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88" target="_blank" rel="noopener noreferrer">《十万个为什么》</a>的作者，前网文时代的先驱），写了一本叫做<a href="https://zh.wikipedia.org/wiki/%E5%B0%8F%E7%81%B5%E9%80%9A%E6%BC%AB%E6%B8%B8%E6%9C%AA%E6%9D%A5" target="_blank" rel="noopener noreferrer">《小灵通漫游未来》</a>的科普小说。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c01-01.png" alt="《小灵通漫游未来》" tabindex="0" loading="lazy"><figcaption>《小灵通漫游未来》</figcaption></figure><p>书中提到了<code>可视电话</code>、<code>电子表</code>、<code>家庭机器人</code>、<code>助听器</code>、<code>隐形眼镜</code>、<code>人造食品</code>、<code>语音识别</code>、<code>远程教学</code>等诸多<code>科学幻想</code>。时至今日，这些当年的<code>痴心妄想</code>早已成为现在人人都习以为常的东西。而这其中，计算机所起到的作用居功至伟。 计算机确实帮助人们做到了很多很多不可思议的事情，它渗透到从银行、证券、通信、能源、交通、电力、水利、农业、基建、制造、天文、贸易、医学、教育、住房、旅行、购物、交友到互联网的方方面面，它让我们得以自由地探索自己和外面的大千世界。“计算<code>是计算机存在的目的和意义，一切都为</code>算力<code>（Computility）而生，为了能更快更高效地</code>计算<code>，在计算机的发展历程中，偶然里又带着必然。 世界上第一台</code>通用`计算机有个好听的名字：<a href="https://en.wikipedia.org/wiki/ENIAC" target="_blank" rel="noopener noreferrer">埃尼阿克（ENIAC，Electronic Numerical Integrator And Computer，电子数字积分计算机）</a>。严格来说，它不能叫做计算机，只能说是有一间房子那么大的计算器（而且还是世界上第二台计算器，不是第一台）。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c01-02.png" alt="世界上第一台计算机ENIAC" tabindex="0" loading="lazy"><figcaption>世界上第一台<code>通用</code>计算机ENIAC</figcaption></figure><p>因为ENIAC主要是由真空管拼凑起来的，里面包括了几百个电子逻辑门、开关和电线。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c01-03.png" alt="各种逻辑电路" tabindex="0" loading="lazy"><figcaption>各种逻辑电路</figcaption></figure><p>所以也可以把ENIAC看成浑身长满大<code>灯泡</code>的铁箱子。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c01-04.png" alt="浑身长满大的铁箱子" tabindex="0" loading="lazy"><figcaption>浑身长满大<code>灯泡</code>的铁箱子</figcaption></figure><figure><img src="https://tianmazuo.com/book/prune/mybook-c01-05.png" alt="浑身长满大的铁箱子" tabindex="0" loading="lazy"><figcaption>浑身长满大<code>灯泡</code>的铁箱子</figcaption></figure><p>电子计算机由电力驱动，而这些构成逻辑门的真空管只有两种状态：不是被<code>打开</code>的状态，就是被<code>关闭</code>的状态（在物理学尚还存在情况下，不可能有第三种状态）。所以为了数学和物理表达上的简便，就用<code>1</code>表示<code>开</code>，用<code>0</code>表示<code>关</code>——计算机中的二进制由此诞生。 但在电子计算机诞生的一个多世纪以前（也就是1834年），就已经有人构思出了现代计算机的完整雏形——分析机。它拥有分工明确的处理器、控制器、存储器、输入与输出等不同装置，它是一个叫<a href="https://zh.wikipedia.org/wiki/%E6%9F%A5%E5%B0%94%E6%96%AF%C2%B7%E5%B7%B4%E8%B4%9D%E5%A5%87" target="_blank" rel="noopener noreferrer">查尔斯·巴贝奇（Charles Babbage）</a>的英国天才发明家的杰作。只是由于他的设计<code>过于先进</code>，那时候的世界还制造不出他所需要的设备，达不到他所要求的工艺精度而无法实现这种构想。直到100多年后，在<code>万事俱备，只欠东风</code>时，才由一个叫<a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%BF%B0%C2%B7%E5%86%AF%E8%AF%BA%E4%BC%8A%E6%9B%BC" target="_blank" rel="noopener noreferrer">约翰·冯·诺依曼</a>的匈牙利裔美籍数学家、计算机科学家、物理学家、化学家、博弈论之父，跨越时空实现了<a href="https://zh.wikipedia.org/wiki/%E6%9F%A5%E5%B0%94%E6%96%AF%C2%B7%E5%B7%B4%E8%B4%9D%E5%A5%87" target="_blank" rel="noopener noreferrer">查尔斯·巴贝奇（Charles Babbage）</a>的天才构想。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c01-06.png" alt="约翰·冯·诺依曼" tabindex="0" loading="lazy"><figcaption>约翰·冯·诺依曼</figcaption></figure><p>虽然关于谁才是真正的<code>计算机之父</code>至今没有确切的定论，有人认为是<a href="https://zh.wikipedia.org/wiki/%E6%9F%A5%E5%B0%94%E6%96%AF%C2%B7%E5%B7%B4%E8%B4%9D%E5%A5%87" target="_blank" rel="noopener noreferrer">查尔斯·巴贝奇（Charles Babbage）</a>（通用计算机之父），有人认为是<a href="https://zh.wikipedia.org/wiki/%E8%89%BE%E4%BC%A6%C2%B7%E5%9B%BE%E7%81%B5" target="_blank" rel="noopener noreferrer">阿兰·图灵</a>（计算机科学之父），有人认为是<a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%BF%B0%C2%B7%E6%96%87%E6%A3%AE%E7%89%B9%C2%B7%E9%98%BF%E5%A1%94%E7%BA%B3%E7%B4%A2%E5%A4%AB" target="_blank" rel="noopener noreferrer">约翰·阿坦那索夫</a>（电子计算机之父），还有人认为是<a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%BF%B0%C2%B7%E5%86%AF%E8%AF%BA%E4%BC%8A%E6%9B%BC" target="_blank" rel="noopener noreferrer">约翰·冯·诺依曼</a>（现代计算机之父）。</p><p>从不同的侧面来说，这都对，但是笔者认为，<a href="https://zh.wikipedia.org/wiki/%E6%9F%A5%E5%B0%94%E6%96%AF%C2%B7%E5%B7%B4%E8%B4%9D%E5%A5%87" target="_blank" rel="noopener noreferrer">查尔斯·巴贝奇（Charles Babbage）</a>太过于超前，在错误的时间得到正确的结果，抱憾终生；<a href="https://zh.wikipedia.org/wiki/%E8%89%BE%E4%BC%A6%C2%B7%E5%9B%BE%E7%81%B5" target="_blank" rel="noopener noreferrer">阿兰·图灵</a>更侧重于密码学和人工智能在计算机上的应用；而<a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%BF%B0%C2%B7%E6%96%87%E6%A3%AE%E7%89%B9%C2%B7%E9%98%BF%E5%A1%94%E7%BA%B3%E7%B4%A2%E5%A4%AB" target="_blank" rel="noopener noreferrer">约翰·阿坦那索夫</a>虽然也摸到了现代计算机体系结构的大门，但终归还是一颗<code>近失弹</code>（Near miss，军事术语，意思就是在极近的距离下失去目标，虽无杀伤但冲击力极大）。他们当中，只有<a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%BF%B0%C2%B7%E5%86%AF%E8%AF%BA%E4%BC%8A%E6%9B%BC" target="_blank" rel="noopener noreferrer">冯·诺依曼</a>是站在巨人的肩膀上（包括利用了<a href="https://zh.wikipedia.org/wiki/%E6%88%88%E7%89%B9%E5%BC%97%E9%87%8C%E5%BE%B7%C2%B7%E8%8E%B1%E5%B8%83%E5%B0%BC%E8%8C%A8" target="_blank" rel="noopener noreferrer">莱布尼兹</a>发明的二进制和<a href="https://zh.wikipedia.org/wiki/%E6%9F%A5%E5%B0%94%E6%96%AF%C2%B7%E5%B7%B4%E8%B4%9D%E5%A5%87" target="_blank" rel="noopener noreferrer">查尔斯·巴贝奇（Charles Babbage）</a>提出的通用计算机的设计理念等），第一次完整地提出了现代计算机体系结构的基本思想。</p><p>在1944年，<a href="https://en.wikipedia.org/wiki/ENIAC" target="_blank" rel="noopener noreferrer">ENIAC</a>还未建成之时，<a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%BF%B0%C2%B7%E5%86%AF%E8%AF%BA%E4%BC%8A%E6%9B%BC" target="_blank" rel="noopener noreferrer">冯·诺依曼</a>在返回洛斯·阿拉莫斯的列车上写出了那篇长达101页且影响整个计算机历史走向的<a href="https://zh.wikipedia.org/zh-cn/EDVAC%E5%A0%B1%E5%91%8A%E6%9B%B8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%BB%BD%E8%8D%89%E6%A1%88" target="_blank" rel="noopener noreferrer">《EDVAC报告书的第一份草案》</a>，准备着手设计建造<a href="https://en.wikipedia.org/wiki/EDVAC" target="_blank" rel="noopener noreferrer">EDVAC（Electronic Discrete Variable Automatic Computer，电子离散变量自动计算机）</a>。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c01-07.png" alt="EDVAC报告书的第一份草案" tabindex="0" loading="lazy"><figcaption>EDVAC报告书的第一份草案</figcaption></figure><p>这份草案不仅详细说明了<a href="https://en.wikipedia.org/wiki/EDVAC" target="_blank" rel="noopener noreferrer">EDVAC</a>的设计思路，也为现代计算机的发展指明了道路。</p><ul><li><p>计算机使用二进制表示数据。</p></li><li><p>计算机要像存储数据一样存储程序。</p></li><li><p>计算机由运算器、控制器、存储器、输入和输出五大部分组成。</p></li></ul><p>这最终奠定了现代<a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%BF%B0%C2%B7%E5%86%AF%E8%AF%BA%E4%BC%8A%E6%9B%BC" target="_blank" rel="noopener noreferrer">冯·诺依曼</a>型计算机的体系结构（以下简称<code>冯·诺依曼机</code>）。在<code>冯·诺依曼机</code>中规定：指令和数据要事先保存在存储器中，然后控制器按地址编码顺序逐一取出这些指令和数据，由运算器执行指令功能，完成计算任务。同时，也规定了<code>冯·诺依曼机</code>必须具备的五大功能。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c01-08.png" alt="冯·诺依曼机体系结构" tabindex="0" loading="lazy"><figcaption>冯·诺依曼机体系结构</figcaption></figure><ul><li><p>输入/输出功能。计算机必须能输入数据和指令（也就是解题步骤），同时能够把按照要求把计算结果和计算过程中输出给用户。</p></li><li><p>存储功能。计算机必须有能够长期记忆数据、指令、计算的中间结果和最终结果的能力。</p></li><li><p>计算功能。这是计算机的核心功能，它必须能够完成各种算术和逻辑的运算，并能进行数据传送和数据加工的能力。</p></li><li><p>判断功能。计算机必须具备控制程序走向，从预先设定的若干种方案中选择一种方案的能力。</p></li><li><p>控制功能。计算机必须具备保证执行的正确性和控制各部件之间正确协调的能力。</p></li></ul><p>从那时起直到现在，不管是巨型机、大型机、中型机、小型机还是微型机（个人计算机）；不管是台式机、笔记本、PAD（平板电脑）、PDA（个人数字助理，在工业、医疗、物流等行业广泛使用，例如，抄表器、扫码枪、护理机）、智能手机还是智能电视，全世界大部分的计算机都还是遵照<code>冯·诺依曼机</code>所规定的体系结构设计和制造出来的。</p><p>当然，世界上除了<code>冯·诺依曼机</code>还有一些其他体系结构的计算机，例如光子计算机、分子计算机、量子计算机等，除非有特别说明，不然在一般情况下，本书后续的内容都是建立在<code>冯·诺依曼机</code>的基础上进行论述的。</p><br><h2 id="二进制" tabindex="-1"><a class="header-anchor" href="#二进制"><span>二进制</span></a></h2><p>可以看到，中间部分第一行第二至四列的内容分别为<code>01010000</code>、<code>01001110</code>和<code>01000111</code>，它们分别对应ASCII码表中的<code>P</code>、<code>N</code>、<code>G</code>。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c01-09.png" alt="、、所对应的ASCII码" tabindex="0" loading="lazy"><figcaption><code>P</code>、<code>N</code>、<code>G</code>所对应的ASCII码</figcaption></figure><p>这正是这个文件名的后缀。这是巧合吗？不是！因为在右边部分的剩余内容中可以看到其他和这个文件相关的一些信息，如创建文件的软件工具，文件创建时间等信息，这和用<code>Windows</code>显示出来的信息是一致的，而且用<code>Hex Editor Neo</code>软件展示出来的内容更多。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c01-10.png" alt="图形文件的属性信息" tabindex="0" loading="lazy"><figcaption>图形文件的属性信息</figcaption></figure><p>这里没有逐一对照用<code>Hex Editor Neo</code>软件和<code>Windows</code>属性面板展示出来的信息之间有什么不同，但如果按数学方式来表示的话，可以断定：<code>Windows</code>属性集一定是二进制内容的子集。有兴趣的读者还可以尝试用画图软件创建<code>10×10</code>像素的黑色正方形，再用<code>Hex Editor Neo</code>软件比对一下和白色正方形之间的二进制内容有什么不一样，这里就不继续了。 从这个意义上说，如果能够完全掌握用二进制创建文件的规则，是不是可以用<code>Hex Editor Neo</code>代替任何软件呢？例如，用<code>Hex Editor Neo</code>代替文本编辑器，代替<code>Word</code>，代替<code>Photoshop</code>，甚至代替<a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener noreferrer">IDEA</a>来编程呢？这不但理论上是完全可以的，而且事实上也确实可行。不过，却不会有人真那么做，因为太费时费力，效率太低！</p><p>可以把同样类型的文件（例如，<code>PNG</code>图片）多创建几个，仅改变不同文件之间的尺寸和颜色，然后通过二进制进行比对，就可以发现这样一个事实：我们平常所看到的任何文件，除了文件的内容本身，还含有一部分附加信息。这些附加信息用户是看不到的，即使看到了也没有意义。因为它们是给计算机操作系统准备的，用以区分各类不同的文件类型及读取、存储方式，如下图所示的那样。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c01-11.png" alt="操作系统读取二进制内容的方式" tabindex="0" loading="lazy"><figcaption>操作系统读取二进制内容的方式</figcaption></figure><p>从上图可以看出，操作系统及其中的各种软件是这样工作的。</p><ul><li><p>读取时，操作系统通过这些附加信息就知道这种文件该给交由哪种软件处理、转译并展示。</p></li><li><p>存储时，各种软件会给文件额外增加专属的附加信息（软件安装时就会在操作系统的注册表中<code>登记</code>这些附加信息）。</p></li><li><p>卸载后，由于对应的附加信息被一并清除，所以操作系统也就不知道对应类型的文件该给哪种软件处理了。</p></li></ul><p>这种附加信息有一个计算机专有名词术语：文件头。这也正是操作系统及各种应用软件存在的意义：有些文件头十分庞大，如果要人力用二进制的方式编写完成，无疑既费力又不讨好，但计算机却十分擅长这种精确无误的重复性劳动。</p><p>另外，如果有些读者真想挑战一下用二进制创建文件，可以试试<a href="https://www.code.org/" target="_blank" rel="noopener noreferrer">code.org</a>网站。这是由微软开发的一个计算机科学入门的免费的网上实验室，有一些好玩的小东西。比如下面就是笔者做的一个简单二进制演示，有兴趣的读者可以自己玩一玩。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c01-12.png" alt="用数字绘图" tabindex="0" loading="lazy"><figcaption>用数字绘图</figcaption></figure><p>稍做说明：图中小框是左边图片区域的宽和高，也就是白色小方块的行数和列数（上方也可以直接输入指定），大框是图片中的内容部分：由白色的小方块和黑色小方块拼成的<code>Java</code>组成。其中<code>1</code>代表白色背景小方块，而<code>0</code>代表黑色绘图线条小方块。</p><br><h2 id="位深、采样率和码率" tabindex="-1"><a class="header-anchor" href="#位深、采样率和码率"><span>位深、采样率和码率</span></a></h2><p>多媒体这个词已经成为了互联网的一部分，如果有些读者希望从事多媒体开发，那么位深、采样率和码率这几个和二进制相关的概念就不能不了解。而且在视频和音频中，这几个文字相同的名词，其意思还有些差别。 所谓<a href="https://baike.baidu.com/item/%E4%BD%8D%E6%B7%B1%E5%BA%A6" target="_blank" rel="noopener noreferrer">位深（Bit Depth）</a>，在图像领域，指的是在分辨率不变的情况下，每一个像素点可以容纳多少种色彩，单位为<code>bit</code>。在计算机成像中，每个像素都由红绿蓝三基色组合而成（RGB色彩模式），每种基色被称为<code>颜色通道</code>。位深可以作用于颜色通道（此时为<code>每通道比特数</code>），也可以作用于像素点（此时为<code>每像素比特数</code>，Bits Per Pixel，称为bpp）。</p><p>一般的彩色图像成像时，其每通道比特数为8，也就是每种基色可以有28（2的8次方，即256）个不同的强度值，例如暗红、深红、大红、粉红等不同强度。而每个像素是三种基色组合在一起的。所以对一个8位的像素来说，三个颜色通道组合在一起就可呈现出超过28×3=1670万种不同的颜色或<code>真彩色</code>。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c01-13.png" alt="8位位深" tabindex="0" loading="lazy"><figcaption>8位位深</figcaption></figure><p>为了更直观地说明位深的效果，可以看看下面这张图。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c01-14.png" alt="不同位深的效果" tabindex="0" loading="lazy"><figcaption>不同位深的效果</figcaption></figure><p>可以看到，位深越大，图像质量越高。根据不同的图像位深，下面列出了关于位深的一些相关信息。</p><table><thead><tr><th style="text-align:center;">位深</th><th style="text-align:center;">可用颜色总数</th><th style="text-align:center;">分辨率的通用名称</th><th style="text-align:center;">分辨率</th></tr></thead><tbody><tr><td style="text-align:center;">1</td><td style="text-align:center;">2</td><td style="text-align:center;">单色</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">2</td><td style="text-align:center;">4</td><td style="text-align:center;">CGA</td><td style="text-align:center;">320 × 200</td></tr><tr><td style="text-align:center;">4</td><td style="text-align:center;">16</td><td style="text-align:center;">EGA</td><td style="text-align:center;">640 × 350</td></tr><tr><td style="text-align:center;">8</td><td style="text-align:center;">256</td><td style="text-align:center;">VGA</td><td style="text-align:center;">640 × 480</td></tr><tr><td style="text-align:center;">16</td><td style="text-align:center;">65535</td><td style="text-align:center;">SVGA，增强色</td><td style="text-align:center;">800 × 600</td></tr><tr><td style="text-align:center;">24</td><td style="text-align:center;">16777216</td><td style="text-align:center;">XGA，真彩色</td><td style="text-align:center;">1024 × 768</td></tr></tbody></table><p>在数字音频系统中，计算机需要通过声卡将模拟信号转换为数字信号才能得到音频信息。声卡能够很轻松地进行每秒上万次的采样，每一次的采样都会记录声波在某一时刻的状态，这个东西就叫<code>样本</code>。把这一连串的样本连接起来时，就组成了一段完整的声波。因此，所谓<a href="https://zh.wikipedia.org/wiki/%E9%87%87%E6%A0%B7%E7%8E%87" target="_blank" rel="noopener noreferrer">采样率</a>就是声卡每秒钟所采集的样本数量，单位为<a href="https://zh.wikipedia.org/wiki/%E8%B5%AB%E5%85%B9" target="_blank" rel="noopener noreferrer">赫兹Hz</a>。例如48000Hz，也就是每秒采样数为48KHz。自然，采样率越高，就说明每秒采集的样本数越多，拼接出的声波质量就越好。 在音频领域，位深也被称为<a href="https://baike.baidu.com/item/%E9%87%87%E6%A0%B7%E7%B2%BE%E5%BA%A6" target="_blank" rel="noopener noreferrer">采样精度</a>，表示每个样本中所包含的比特数。常见的位深有16Bit和24Bit。</p><p>最后，<a href="https://zh.wikipedia.org/wiki/%E7%A0%81%E7%8E%87%E5%8D%95%E4%BD%8D" target="_blank" rel="noopener noreferrer">码率</a>，其实也就是<a href="https://zh.wikipedia.org/zh-hans/%E6%AF%94%E7%89%B9%E7%8E%87" target="_blank" rel="noopener noreferrer">比特率</a>，音视频中都有<code>码率</code>一说。它指的是单位时间内传输或处理的比特数量，和带宽的概念有些类似。显而易见，单位时间内，传输的比特数越多，声音就越清晰，视频画质就越好。 其实，在多媒体领域的相关开发工作中，还有很多的名词术语和相关概念，例如<code>编码模式</code>、<code>编码格式</code>、<code>制式</code>、<code>帧率</code>、<code>场序</code>、<code>灰度级数</code>、<code>DTS &amp; PTS</code>、<code>GOP</code>、<code>IDR帧</code>、<code>跨距</code>等，但其本质都是上大同小异的，不过就是对二进制数据的传输、处理和存储的方式不同而已。</p><br><h2 id="树型数据结构" tabindex="-1"><a class="header-anchor" href="#树型数据结构"><span>树型数据结构</span></a></h2><p><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9" target="_blank" rel="noopener noreferrer">二叉查找树（BST）</a>又称二叉搜索树，它是一颗二叉树。</p><ul><li><p>若其左子树不空，则左子树上节点的值必定小于它根节点的值。</p></li><li><p>若其右子树不空，则右子树上节点的值必定大于它根节点的值。</p></li><li><p>任意节点的左右子树也都是二叉查找树。</p></li></ul><p><a href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9" target="_blank" rel="noopener noreferrer">平衡二叉树（AVL）</a>是一颗二叉查找树，其左右子树的高度差的绝对值不超过1，且左右子树也都是平衡二叉树。</p><p><a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="noopener noreferrer">红黑树（RBT）</a>是一颗二叉查找树。</p><ul><li><p>根节点和叶子节点都是黑色的，且叶子节点都是值为null的节点。</p></li><li><p>每个节点要么是红色的，要么是黑色的。</p></li><li><p>红色节点的子节点和父节点都是黑色的。</p></li><li><p>从任一节点到叶子节点，其路径上包含的黑色节点数量相同。</p></li></ul><figure><img src="https://tianmazuo.com/book/prune/mybook-c01-15.png" alt="二叉查找树、平衡二叉树和红黑树" tabindex="0" loading="lazy"><figcaption>二叉查找树、平衡二叉树和红黑树</figcaption></figure><p><a href="https://zh.wikipedia.org/wiki/B%E6%A0%91" target="_blank" rel="noopener noreferrer">B树</a>在有些文档或资料中也叫<code>B-树</code>，但称它为<code>B-树</code>有些不妥，因为称其为<code>B-树</code>，可能会让人误认为是另一种数据结构。所以没有所谓的<code>B-树</code>，只有<a href="https://zh.wikipedia.org/wiki/B%E6%A0%91" target="_blank" rel="noopener noreferrer">B树</a>。</p><p>一个<code>m阶</code>的<a href="https://zh.wikipedia.org/wiki/B%E6%A0%91" target="_blank" rel="noopener noreferrer">B树</a>具有如下定义。</p><ul><li><p>根节点不是叶子节点时，根节点有n个子节点，2 &lt;= n &lt;= m。</p></li><li><p>每个内部节点都至少有n个子节点，n = <code>Math.ceil(m / 2)</code>。且其所含键k的数量范围为<code>n - 1 &lt;= k &lt;= m - 1</code>，键是用于指向数据记录的指针。<code>Math.ceil()</code>函数表示向上取整，例如<code>Math.ceil(1.1)</code>和<code>Math.ceil(1.8)</code>向上取整的结果都为2。</p></li><li><p>有n个键的非叶子节点必须有n + 1个子节点。</p></li><li><p>所有叶子节点的深度（或高度）都一样，也就是说它们都要在同一层。</p></li><li><p>每个节点中键的数值都从小到大排序，且每个节点的子树也按照下列顺序从左至右依次排列。</p><ul><li><p>第一个子树的所有键值都小于其父节点的最小键值。</p></li><li><p>第二个子树的所有键值都大于其父节点的最小键值，而又小于其父节点的第二小键值。</p></li><li><p>其他中间子树的键值属性及排列位置依此类推。</p></li><li><p>最后一个子树的所有键值都大于其父节点的最大键值。</p></li></ul></li></ul><figure><img src="https://tianmazuo.com/book/prune/mybook-c01-16.png" alt="B树" tabindex="0" loading="lazy"><figcaption>B树</figcaption></figure><p>从上图也可以很容易地看出键值排列的规律。</p><ul><li><p>左节点B中的所有键值都要小于父节点A中最小的键值<code>8</code>。</p></li><li><p>中间节点C中所有键值都要大于父节点A的最小键值<code>8</code>，但又都小于父节点A第二小的键值<code>11</code>。</p></li><li><p>右节点D中的所有键值都要大于父节点A中最大的键值<code>11</code>。</p></li></ul><p>下面展示了<a href="https://zh.wikipedia.org/wiki/B%E6%A0%91" target="_blank" rel="noopener noreferrer">B树</a>从1到14的插值生成过程。如果阶数太少说明不了问题，但阶数多了过程又太冗长。以4阶<a href="https://zh.wikipedia.org/wiki/B%E6%A0%91" target="_blank" rel="noopener noreferrer">B树</a>作为演示刚好合适。在4阶<a href="https://zh.wikipedia.org/wiki/B%E6%A0%91" target="_blank" rel="noopener noreferrer">B树</a>中，每个结点最多只4个子节点，最多只有3个键<code>（key = m阶 - 1）</code>，最少有1个键<code>（key = Math.ceil(m / 2) - 1）</code>，有n个键的非叶子节点必须有n + 1个子节点。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c01-17.png" alt="B树插值过程" tabindex="0" loading="lazy"><figcaption>B树插值过程</figcaption></figure><figure><img src="https://tianmazuo.com/book/prune/mybook-c01-18.png" alt="B树插值过程" tabindex="0" loading="lazy"><figcaption>B树插值过程</figcaption></figure><p>可以看到它和前面<a href="https://zh.wikipedia.org/wiki/B%E6%A0%91" target="_blank" rel="noopener noreferrer">B树</a>的结构有些不同。这也是笔者想指出的<a href="https://zh.wikipedia.org/wiki/B%E6%A0%91" target="_blank" rel="noopener noreferrer">B树</a>的另外一个<code>隐藏</code>属性。</p><ul><li><p>如果不是从1开始插值，而是从其他数开始，也就是说生成B树的插值顺序不同，那么生成的B树也就不同。</p></li><li><p>如果第2步选择键值<code>2</code>作父节点，那么最终生成B树的结果也会不同。</p></li></ul><p>以上两点充分说明：插值顺序和权重对生成<a href="https://zh.wikipedia.org/wiki/B%E6%A0%91" target="_blank" rel="noopener noreferrer">B树</a>的结果有直接影响。这也是很多资料当中都没有提到的一点。</p><p><a href="https://zh.wikipedia.org/wiki/B+%E6%A0%91" target="_blank" rel="noopener noreferrer">B+树</a>和<a href="https://zh.wikipedia.org/wiki/B%E6%A0%91" target="_blank" rel="noopener noreferrer">B树</a>类似，它在其基础上做了一些改变。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c01-19.png" alt="B+树" tabindex="0" loading="lazy"><figcaption>B+树</figcaption></figure><ul><li><p>节点分为两种不同的类型：索引节点和数据节点。</p></li><li><p>所有数据节点全部都是叶子节点，其他子节点只存储索引。</p></li><li><p>每个叶子节点都存有相邻叶子节点的索引，如此组成一个单向链表。</p></li><li><p>父节点存有右子节点第一个元素的索引。</p></li></ul><p><a href="https://zh.wikipedia.org/wiki/B+%E6%A0%91" target="_blank" rel="noopener noreferrer">B+树</a>的生成和<a href="https://zh.wikipedia.org/wiki/B%E6%A0%91" target="_blank" rel="noopener noreferrer">B树</a>非常类似，只是它所有的数据都在叶子节点上而已，此处就不再展示其生成过程了。</p><p>在树型数据结构中，<a href="https://zh.wikipedia.org/wiki/B+%E6%A0%91" target="_blank" rel="noopener noreferrer">B+树</a>的生成和<a href="https://zh.wikipedia.org/wiki/B%E6%A0%91" target="_blank" rel="noopener noreferrer">B树</a>比较复杂，如果是需要开发文件系统一类的应用，或者数据库底层存储，那就必须要深入掌握它所涉及到的每一个技术细节，否则，了解其原理就行了。</p><p>只不过<a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>的底层存储是通过<a href="https://zh.wikipedia.org/wiki/B+%E6%A0%91" target="_blank" rel="noopener noreferrer">B+树</a>实现的，所以有些面试官比较爱问相关的问题。</p><br><h2 id="中断与轮询" tabindex="-1"><a class="header-anchor" href="#中断与轮询"><span>中断与轮询</span></a></h2><p>另一个和并发比较类似且相关的概念，也在此一并澄清，那就是<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%96%B7" target="_blank" rel="noopener noreferrer">中断（Interrupts）</a>与<a href="https://baike.baidu.com/item/%E8%BD%AE%E8%AF%A2" target="_blank" rel="noopener noreferrer">轮询（Polling）</a>。</p><p>所谓<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%96%B7" target="_blank" rel="noopener noreferrer">中断</a>，就是由计算机硬件或软件发出的一种<code>请求（IRQ，Interupt ReQuest）</code>信号，一旦CPU收到这种信号就会保留目前的执行状态（现场）并暂停执行当前的任务，转而去响应中断请求。这个中断请求对CPU来说是被动的，因为CPU并不知道它什么时候会发生。比如，当用户正在用USB设备拷贝资料时，如果这时候突然打开一个很大的文本文件（可能几百MB），性能较差的计算机就会明显看到卡顿现象。这种卡顿就是因为CPU被中断拷贝任务以后，去执行打开文件的操作了。由于性能较差，所以读取速度较慢，也就会出现了卡顿。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c01-20.png" alt="过程" tabindex="0" loading="lazy"><figcaption><code>中断</code>过程</figcaption></figure><p>可以从图中看出，当CPU正在执行拷贝资料的任务时，突然收到一个<code>IRQ请求</code>，CPU立即响应它，在保护好前一任务现场的同时，马上执行打开文件的任务。如果拷贝资料的任务并未停止或结束，且文件较大，那么CPU此时可能就会进入并发工作模式，将工作时间片轮流分配给它们。这种通过时间片定时<code>询问</code>设备工作状态的机制，就叫做<a href="https://baike.baidu.com/item/%E8%BD%AE%E8%AF%A2" target="_blank" rel="noopener noreferrer">轮询（Polling）</a>。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c01-21.png" alt="过程" tabindex="0" loading="lazy"><figcaption><code>轮询</code>过程</figcaption></figure><p>计算机上的<code>I/O</code>设备都有一个状态寄存器，用于存储当前设备的工作状态。通过不断查询这个设备状态寄存器中的数据，CPU就可以准确地知道当前系统的整体运行情况，从而执行可能到来的I/O操作。为了节约CPU资源，轮询不是一直持续的，而是以固定时间间隔的方式执行。这种CPU级的时间间隔一般以毫秒甚至微秒为单位，人类无法感知。这也就是为什么并发工作模式会让人觉得好像是多个任务同时在执行的原因——快到让人察觉不到。可以说，CPU的并发工作模式正是因为有了中断与轮询的技术支持才得以运行。</p><p>至于<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%96%B7" target="_blank" rel="noopener noreferrer">中断</a>与<a href="https://baike.baidu.com/item/%E8%BD%AE%E8%AF%A2" target="_blank" rel="noopener noreferrer">轮询</a>的技术细节不必深究，这属于计算机硬件体系结构相关的领域，与本书内容所涉及的范畴无关。</p><br><h2 id="国际化、本地化与全球化" tabindex="-1"><a class="header-anchor" href="#国际化、本地化与全球化"><span>国际化、本地化与全球化</span></a></h2><p><a href="https://en.wikipedia.org/wiki/Internationalization_and_localization" target="_blank" rel="noopener noreferrer">国际化（Internationalization，又称i18n）与本地化（Localization，又称l10n）</a>其实与技术没有多大关系，但是作为一名拥护并追求极致工程师文化的软件开发工程师，笔者思虑之后还是把它放在了本章的最后一节。一是希望人人都能开发出高质量且高可用（这里并非指性能，而是实用性）的软件。二是希望咱们软件产业能响应国家政策的号召，为<code>走出去</code>做好充分的常识性准备。 不同的国家和地区有不同的语言、政策、律法、价值观、货币、度量单位，甚至是日期、历法等文明印记。如果希望自己开发出来的软件或应用，可以仅凭一套代码在世界范围内发布，以最低成本快速适应全球需要，那么就要做好充分的国际化工作。</p><ul><li><p>文本编码：例如将<code>ISO/IEC 8859</code>转换为<code>Unicode</code>，将中文中的标点符号都转换为相适应的标点符号。</p></li><li><p>数据适配：包括货币格式、汇率、度量单位（公斤转换为英镑、公里转为英里）、时区（北京时间转换为纽约时间）、日期格式、电话格式、地址格式、数字格式（中文数字转换为阿拉伯数字）。</p></li><li><p>功能适配：例如有些地区还没有移动支付或电子支付手段，那么就需要适应当地的支付方式，如VISA、MASTER等信用卡支付或者面对面的现金支付方式。</p></li><li><p>文化适配：在有些国家，红色可能不代表热烈，而是代表禁忌。</p></li><li><p>政策律法适配：需要遵守当地的法律、法规和条例，例如欧盟GDPR条例等。</p></li></ul><p>如果说国际化是一套框架和方向，规定了软件需要进军海外的各项准备工作的话，那么本地化就是来具体完成这些工作的流程和手段。它针对的是具体的国家和地区需要执行转换的那些工作。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c01-22.png" alt="的一般流程" tabindex="0" loading="lazy"><figcaption><code>本地化</code>的一般流程</figcaption></figure><ul><li><p>①首先是由营销部门整理产品中所有涉及到需要进行本地化的内容。</p></li><li><p>②开发团队根据营销部门整理的内容，结合源码提取出需要转译的语言字符、数据、功能等本地化工作任务。</p></li><li><p>③将本地化任务交给转译管理平台完成转译工作。这个转译管理平台可以是开源框架，可以是公司自研的软件工具，可以是第三方平台API、SDK，或者也可以是专业外包的产品全球化组织。</p></li><li><p>④转译管理平台完成本地化任务后，将内容输出给开发团队。</p></li><li><p>⑤开发团队整合转译管理平台的输出内容后开始集成并部署。</p></li><li><p>⑥发布的第一个版本作为内测版本开始测试，发现可能出现的本地化问题。</p></li><li><p>⑦内测通过后再扩大范围，开始小规模发布，交由一些种子用户或志愿者进行公测。</p></li><li><p>⑧公测通过后就可以正式发布了，在整个使用过程中还会不断地改进和完善。</p></li></ul><p>除了上面的那套流程，完整的本地化其实还包括一些更高、更抽象层次上的内容，它包括但不限于SEO本地化、产品设计本地化、开发流程本地化、技术标准本地化、售后服务的本地化等。 从全局上来说，国际化和本地化都是<a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E7%90%83%E5%8C%96" target="_blank" rel="noopener noreferrer">全球化（Globalization，又称g11n）</a>的一个子集。</p><figure><img src="https://tianmazuo.com/book/prune/mybook-c01-23.png" alt="全球化" tabindex="0" loading="lazy"><figcaption>全球化</figcaption></figure><p><a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E7%90%83%E5%8C%96" target="_blank" rel="noopener noreferrer">全球化</a>代表的是一整套软件产品从设计、研发、测试再到全球营销落地的完整服务流程，它在更高的层次上关注研发管理、市场营销、售后服务等各业务环节。因此，优秀的全球化实践，其实就是向客户提供更好的产品和服务体验的实践。</p>',94),n=[a];function p(c,l){return t(),o("div",null,n)}const h=e(i,[["render",p],["__file","chapter01.html.vue"]]),k=JSON.parse('{"path":"/book/prune/chapter01.html","title":"《第1章 编程常识》节略部分","lang":"zh-CN","frontmatter":{"title":"《第1章 编程常识》节略部分","icon":"receipt","category":["电子书","节略章节合辑"],"tag":["电子书","节略章节合辑"],"date":"2024-07-05T00:00:00.000Z","isOriginal":true,"star":true,"description":"统治地球的冯·诺依曼们 1961年，一个叫叶永烈的21岁青年（他也是《十万个为什么》的作者，前网文时代的先驱），写了一本叫做《小灵通漫游未来》的科普小说。 《小灵通漫游未来》《小灵通漫游未来》 书中提到了可视电话、电子表、家庭机器人、助听器、隐形眼镜、人造食品、语音识别、远程教学等诸多科学幻想。时至今日，这些当年的痴心妄想早已成为现在人人都习以为常的东...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/book/prune/chapter01.html"}],["meta",{"property":"og:site_name","content":"添码座"}],["meta",{"property":"og:title","content":"《第1章 编程常识》节略部分"}],["meta",{"property":"og:description","content":"统治地球的冯·诺依曼们 1961年，一个叫叶永烈的21岁青年（他也是《十万个为什么》的作者，前网文时代的先驱），写了一本叫做《小灵通漫游未来》的科普小说。 《小灵通漫游未来》《小灵通漫游未来》 书中提到了可视电话、电子表、家庭机器人、助听器、隐形眼镜、人造食品、语音识别、远程教学等诸多科学幻想。时至今日，这些当年的痴心妄想早已成为现在人人都习以为常的东..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://tianmazuo.com/book/prune/mybook-c01-01.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"添码座"}],["meta",{"property":"article:tag","content":"电子书"}],["meta",{"property":"article:tag","content":"节略章节合辑"}],["meta",{"property":"article:published_time","content":"2024-07-05T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"《第1章 编程常识》节略部分\\",\\"image\\":[\\"https://tianmazuo.com/book/prune/mybook-c01-01.png\\",\\"https://tianmazuo.com/book/prune/mybook-c01-02.png\\",\\"https://tianmazuo.com/book/prune/mybook-c01-03.png\\",\\"https://tianmazuo.com/book/prune/mybook-c01-04.png\\",\\"https://tianmazuo.com/book/prune/mybook-c01-05.png\\",\\"https://tianmazuo.com/book/prune/mybook-c01-06.png\\",\\"https://tianmazuo.com/book/prune/mybook-c01-07.png\\",\\"https://tianmazuo.com/book/prune/mybook-c01-08.png\\",\\"https://tianmazuo.com/book/prune/mybook-c01-09.png\\",\\"https://tianmazuo.com/book/prune/mybook-c01-10.png\\",\\"https://tianmazuo.com/book/prune/mybook-c01-11.png\\",\\"https://tianmazuo.com/book/prune/mybook-c01-12.png\\",\\"https://tianmazuo.com/book/prune/mybook-c01-13.png\\",\\"https://tianmazuo.com/book/prune/mybook-c01-14.png\\",\\"https://tianmazuo.com/book/prune/mybook-c01-15.png\\",\\"https://tianmazuo.com/book/prune/mybook-c01-16.png\\",\\"https://tianmazuo.com/book/prune/mybook-c01-17.png\\",\\"https://tianmazuo.com/book/prune/mybook-c01-18.png\\",\\"https://tianmazuo.com/book/prune/mybook-c01-19.png\\",\\"https://tianmazuo.com/book/prune/mybook-c01-20.png\\",\\"https://tianmazuo.com/book/prune/mybook-c01-21.png\\",\\"https://tianmazuo.com/book/prune/mybook-c01-22.png\\",\\"https://tianmazuo.com/book/prune/mybook-c01-23.png\\"],\\"datePublished\\":\\"2024-07-05T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"添码座\\",\\"url\\":\\"https://www.tianmazuo.com/about/\\"}]}"]]},"headers":[{"level":2,"title":"统治地球的冯·诺依曼们","slug":"统治地球的冯·诺依曼们","link":"#统治地球的冯·诺依曼们","children":[]},{"level":2,"title":"二进制","slug":"二进制","link":"#二进制","children":[]},{"level":2,"title":"位深、采样率和码率","slug":"位深、采样率和码率","link":"#位深、采样率和码率","children":[]},{"level":2,"title":"树型数据结构","slug":"树型数据结构","link":"#树型数据结构","children":[]},{"level":2,"title":"中断与轮询","slug":"中断与轮询","link":"#中断与轮询","children":[]},{"level":2,"title":"国际化、本地化与全球化","slug":"国际化、本地化与全球化","link":"#国际化、本地化与全球化","children":[]}],"git":{},"readingTime":{"minutes":23.74,"words":7123},"filePathRelative":"book/prune/chapter01.md","localizedDate":"2024年7月5日","excerpt":"<h2>统治地球的冯·诺依曼们</h2>\\n<p>1961年，一个叫<a href=\\"https://zh.wikipedia.org/wiki/%E5%8F%B6%E6%B0%B8%E7%83%88\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">叶永烈</a>的21岁青年（他也是<a href=\\"https://zh.wikipedia.org/wiki/%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">《十万个为什么》</a>的作者，前网文时代的先驱），写了一本叫做<a href=\\"https://zh.wikipedia.org/wiki/%E5%B0%8F%E7%81%B5%E9%80%9A%E6%BC%AB%E6%B8%B8%E6%9C%AA%E6%9D%A5\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">《小灵通漫游未来》</a>的科普小说。</p>","autoDesc":true}');export{h as comp,k as data};
