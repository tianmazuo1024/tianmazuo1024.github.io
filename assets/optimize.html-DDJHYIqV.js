import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,o as i,d as a}from"./app-B5m7CcSj.js";const t={},s=a('<h2 id="设计原则" tabindex="-1"><a class="header-anchor" href="#设计原则"><span>设计原则</span></a></h2><h3 id="设置预分区" tabindex="-1"><a class="header-anchor" href="#设置预分区"><span>设置预分区</span></a></h3><ul><li><p><a href="https://hbase.apache.org/" target="_blank" rel="noopener noreferrer">HBase</a>默认新建的表中只有一个<code>HRegion</code>，而且这个<code>HRegion</code>是没有边界的，也就是没有<code>[startRowKey, endRowKey)</code>的存在，所有的读写都集中在这个<code>HRegion</code>上。</p></li><li><p>当<code>HRegion</code>大小超过预定的阈值时，<code>HRegion</code>会进行分裂（<code>Split</code>）。</p></li><li><p>所以<code>读写热点</code>问题和分裂时的<code>I/O</code>问题都会影响<a href="https://hbase.apache.org/" target="_blank" rel="noopener noreferrer">HBase</a>的性能。</p></li><li><p>因此，可以在建表时创建多个空的<code>HRegion</code>，并确定每个<code>HRegion</code>的起点和终点。只要<code>RowKey</code>设计合理，就能让数据均匀地分布在<code>HRegion</code>之中，解决上面的两个问题。</p></li><li><p>这种预先创建空<code>HRegion</code>的方式，就叫<code>预分区</code>。</p></li></ul><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"># 定义5个预分区：</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">~</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">，</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">~</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">200</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">，</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">200</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">~</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">300</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">，</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">300</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">~</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">400</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">，</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">400</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">~</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">hbase:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">001</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> create</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;user&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;info&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, SPLITS</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[&#39;100&#39;,&#39;200&#39;,&#39;300&#39;,&#39;400&#39;]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>预分区信息可以在<a href="http://172.16.185.176:16010/table.jsp?name=user" target="_blank" rel="noopener noreferrer">HBase Web UI Table Regions</a>中看到。</p><h3 id="rowkey的设计" tabindex="-1"><a class="header-anchor" href="#rowkey的设计"><span>RowKey的设计</span></a></h3><ul><li><p><code>RowKey</code>长度原则：越短越好，不要超过16个字节，建议设计为定长。因为它的长度直接决定<code>HFile</code>、<code>MemStore</code>的存储和查询效率。</p></li><li><p><code>RowKey</code>散列原则：为避免数据热点问题，最好将<code>RowKey</code>数据转换成<code>Hash</code>值。例如，如果<code>RowKey</code>为手机号，那么可以这样保存。</p><ul><li><p>将手机号反转，将最后一位作为<code>RowKey</code>的第一位，这样就可以让<code>RowKey</code>比较均匀地分布在<code>0</code> ~ <code>9</code>开头的<code>HRegion</code>中。</p></li><li><p>取手机号全部位数或者后4位做取模运算，然后将余数作为<code>RowKey</code>。需要能够通过这个余数反推出手机号，否则找不到数据。</p></li></ul></li><li><p><code>RowKey</code>唯一原则：如果<code>RowKey</code>相同，数据会被直接覆盖，而不是像<a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>那样报错。</p></li><li><p><code>RowKey</code>设计得是否合理可以通过<a href="http://172.16.185.176:16010/table.jsp?name=user" target="_blank" rel="noopener noreferrer">HBase Web UI Table Regions</a>中表头的<code>ReadRequests</code>和<code>WriteRequests</code>数据观察到。</p></li><li><p>设计不合理的<code>RowKey</code>，它的每个<code>HRegion</code>的<code>ReadRequests</code>（或者<code>WriteRequests</code>）之间的数据必然相差巨大，也就是会出现数据热点问题，否则这些数据会是比较均匀的，数值都相差不大。</p></li><li><p><code>ReadRequests</code>和<code>WriteRequests</code>只在当次<a href="https://hbase.apache.org/" target="_blank" rel="noopener noreferrer">HBase</a>集群运行时有效，一旦<a href="https://hbase.apache.org/" target="_blank" rel="noopener noreferrer">HBase</a>集群重启，<code>ReadRequests</code>和<code>WriteRequests</code>的数值会被清零。</p></li></ul><h3 id="列族的设计" tabindex="-1"><a class="header-anchor" href="#列族的设计"><span>列族的设计</span></a></h3><ul><li><p>把经常读取的字段存储到一个列族中，不经常读取的存到另一个列族中。</p></li><li><p>列族名避免过长或包含特殊字符。</p></li><li><p>限制列族的数量。</p></li><li><p>列族只保留必要的版本，过多的版本会占用更多的存储空间，并降低读取性能。</p></li></ul><h3 id="批量处理" tabindex="-1"><a class="header-anchor" href="#批量处理"><span>批量处理</span></a></h3><p>当数据量不大而想要导入、导出或删除的时候，除了可以利用之前的代码和<a href="https://hbase.apache.org/" target="_blank" rel="noopener noreferrer">HBase</a>自带的工具类外，还可以这样做。</p><ul><li><p>调用<code>Table.get(List&lt;Get&gt;)</code>方法，一次性读取一批数据。</p></li><li><p>调用<code>Table.put(List&lt;Put&gt;)</code>方法，一次性写入一批数据。</p></li><li><p>调用<code>Table.delete(List&lt;Delete&gt;)</code>方法，一次性删除一批数据。</p></li></ul><br><h2 id="核心参数优化" tabindex="-1"><a class="header-anchor" href="#核心参数优化"><span>核心参数优化</span></a></h2><ul><li><p><code>hbase.hregion.majorcompaction</code>：设置<code>HFile</code>大合并的间隔时间，默认为<code>604800000毫秒（7天）</code>，可设置为0，禁止自动大合并，因为大合并的执行过程可能会持续数小 时。为减少对业务的影响，建议在业务低谷期手动，或者通过脚本，或者API定期执行。</p></li><li><p><code>hbase.hregion.max.filesize</code>： 默认值为<code>10737418240 Byte（10G）</code>，当<code>HRegion</code>达到这个阈值时，会自动分裂。<code>HRegion</code>分裂时会有短暂的下线时间(通常在5秒 以内)。为减少对业务端的影响，建议调大该值，并在业务低谷期定时手动执行分裂。</p></li><li><p><code>hbase.regionserver.handler.count</code>： <code>handler</code>用于实现底层数据的发送，默认每批次发送30条。对于大量数据的<code>Put</code>（达到了百万级别）操作或是大范围的<code>Scan</code>操作，<code>handler</code>数目不要过大，否则容易造成<code>OOM（内存溢出）</code>。而对于小负载的<code>put</code>、<code>get</code>，<code>delete</code>等操作，<code>handler</code>则可以适当调大。</p></li><li><p><code>hbase.hregion.memstore.flush.size</code>： 默认<code>134217728 Byte（128MB）</code>，这个参数是<code>MemStore</code>数据持久化到<code>HStoreFile</code>的时机，超过该阈值，则会触发数据持久化操作。如果<code>HRegionServer</code>的内存充足，则可以适当调大该值，这样可以减少<code>MemStore</code>的数据溢写文件的次数。</p></li><li><p><code>hbase.hregion.memstore.block.multiplier</code>： 默认值为4，如果一个<code>MemStore</code>的内存大小已经超过<code>hbase.hregion.memstore.flush.size</code> × <code>hbase.hregion.memstore.block.multiplier</code>，则 会阻塞该<code>MemStore</code>的写操作。为避免阻塞，可以适当调大，例如6~8。但如果太大，则又有<code>OOM</code>的风险。如果在<code>HRegionServer</code>日志中出现<code>&quot;Blocking updates for ‘’ on region :memstoresize &lt;?M&gt; is &gt;= than blocking &lt;?M&gt; size&quot;</code>的信息时，说明这个值该调整了。</p></li><li><p><code>hbase.hstore.compaction.min</code>：默认值为3，如果任何一个<code>Store</code>里的<code>HStoreFile</code>总数超过该值，就会触发合并操作，可以设置为5~8，并在手动的定期大合并中进行<code>HStoreFile</code>文件的合并，减少合并的次数，不过这会延长合并的时间。</p></li><li><p><code>hbase.rpc.timeout</code>：<code>Scan</code>大表时的超时时间，可以适当调大。</p></li></ul><p>这些参数都可以在<code>${HBASE_HOME}/conf/hbase-site.xml</code>中修改。</p><br><h2 id="其他问题" tabindex="-1"><a class="header-anchor" href="#其他问题"><span>其他问题</span></a></h2><ul><li><p>统一各个系统的字符集，非<code>utf8</code>都要统一成<code>utf8</code>。</p></li><li><p><a href="https://hbase.apache.org/" target="_blank" rel="noopener noreferrer">HBase</a>第一次执行查询时会很慢，建议提前初始化链接。</p></li><li><p>每日全量数据入库，数据实际发生变化的条数不多，可以用<code>day2</code>的数据和<code>day1</code>的数据做对比，只入库发生变化的数据。</p></li><li><p>对表做预分区，同时<code>RowKey</code>做<code>MD5 Hash</code>取余。</p></li></ul>',19),d=[s];function l(c,n){return i(),o("div",null,d)}const h=e(t,[["render",l],["__file","optimize.html.vue"]]),g=JSON.parse('{"path":"/technology/bigdata/hbase/optimize.html","title":"几个优化问题","lang":"zh-CN","frontmatter":{"title":"几个优化问题","icon":"barcode","category":["大数据","HBase"],"tag":["大数据","HBase"],"date":"2023-04-05T00:00:00.000Z","isOriginal":true,"star":true,"description":"设计原则 设置预分区 HBase默认新建的表中只有一个HRegion，而且这个HRegion是没有边界的，也就是没有[startRowKey, endRowKey)的存在，所有的读写都集中在这个HRegion上。 当HRegion大小超过预定的阈值时，HRegion会进行分裂（Split）。 所以读写热点问题和分裂时的I/O问题都会影响HBase的性能...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/technology/bigdata/hbase/optimize.html"}],["meta",{"property":"og:site_name","content":"添码座"}],["meta",{"property":"og:title","content":"几个优化问题"}],["meta",{"property":"og:description","content":"设计原则 设置预分区 HBase默认新建的表中只有一个HRegion，而且这个HRegion是没有边界的，也就是没有[startRowKey, endRowKey)的存在，所有的读写都集中在这个HRegion上。 当HRegion大小超过预定的阈值时，HRegion会进行分裂（Split）。 所以读写热点问题和分裂时的I/O问题都会影响HBase的性能..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"添码座"}],["meta",{"property":"article:tag","content":"大数据"}],["meta",{"property":"article:tag","content":"HBase"}],["meta",{"property":"article:published_time","content":"2023-04-05T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"几个优化问题\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-04-05T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"添码座\\",\\"url\\":\\"https://www.tianmazuo.com/about/\\"}]}"]]},"headers":[{"level":2,"title":"设计原则","slug":"设计原则","link":"#设计原则","children":[{"level":3,"title":"设置预分区","slug":"设置预分区","link":"#设置预分区","children":[]},{"level":3,"title":"RowKey的设计","slug":"rowkey的设计","link":"#rowkey的设计","children":[]},{"level":3,"title":"列族的设计","slug":"列族的设计","link":"#列族的设计","children":[]},{"level":3,"title":"批量处理","slug":"批量处理","link":"#批量处理","children":[]}]},{"level":2,"title":"核心参数优化","slug":"核心参数优化","link":"#核心参数优化","children":[]},{"level":2,"title":"其他问题","slug":"其他问题","link":"#其他问题","children":[]}],"git":{},"readingTime":{"minutes":4.67,"words":1402},"filePathRelative":"technology/bigdata/hbase/optimize.md","localizedDate":"2023年4月5日","excerpt":"<h2>设计原则</h2>\\n<h3>设置预分区</h3>\\n<ul>\\n<li>\\n<p><a href=\\"https://hbase.apache.org/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">HBase</a>默认新建的表中只有一个<code>HRegion</code>，而且这个<code>HRegion</code>是没有边界的，也就是没有<code>[startRowKey, endRowKey)</code>的存在，所有的读写都集中在这个<code>HRegion</code>上。</p>\\n</li>\\n<li>\\n<p>当<code>HRegion</code>大小超过预定的阈值时，<code>HRegion</code>会进行分裂（<code>Split</code>）。</p>\\n</li>\\n<li>\\n<p>所以<code>读写热点</code>问题和分裂时的<code>I/O</code>问题都会影响<a href=\\"https://hbase.apache.org/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">HBase</a>的性能。</p>\\n</li>\\n<li>\\n<p>因此，可以在建表时创建多个空的<code>HRegion</code>，并确定每个<code>HRegion</code>的起点和终点。只要<code>RowKey</code>设计合理，就能让数据均匀地分布在<code>HRegion</code>之中，解决上面的两个问题。</p>\\n</li>\\n<li>\\n<p>这种预先创建空<code>HRegion</code>的方式，就叫<code>预分区</code>。</p>\\n</li>\\n</ul>","autoDesc":true}');export{h as comp,g as data};
