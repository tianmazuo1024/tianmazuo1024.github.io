import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as t,c as r,a as s,e,b as o,w as p,d as a,o as l}from"./app-B5m7CcSj.js";const c={},d=a('<h2 id="什么是-设计模式" tabindex="-1"><a class="header-anchor" href="#什么是-设计模式"><span>什么是“设计模式”</span></a></h2><p>众所周知，<strong><mark>算法</mark></strong>、<strong><mark>数据结构</mark></strong> 和 <a href="https://en.wikipedia.org/wiki/Design_Patterns" target="_blank" rel="noopener noreferrer">设计模式</a>一直都是软件开发中讨论话题非常多的几个领域。</p><ul><li><p>如果说 <strong><mark>数据结构</mark></strong> 是一种<code>对数据的组织形式</code>（例如，可以把它看作一棵长满果实的果树）。</p></li><li><p>那么 <strong><mark>算法</mark></strong> 则给出了几种<code>摘果子的方式</code>（例如，<code>深度优先摘取</code>和<code>广度优先摘取</code>）。</p></li><li><p>而<a href="https://en.wikipedia.org/wiki/Design_Patterns" target="_blank" rel="noopener noreferrer">设计模式</a>则是针对整个果园的一种<code>采摘管理方式</code>，它类似于<code>蓝图</code>，指明了<code>低成本与高效</code>的摘取方法。</p></li></ul><blockquote><p>如果从成本和效率方面来衡量的话，<strong><mark>算法和数据结构</mark></strong> 在某种程度上，也算是一种处理数据的高效 <strong><mark>模式</mark></strong>。</p></blockquote><p>模式的概念最初是由<a href="https://zh.wikipedia.org/wiki/%E5%85%8B%E9%87%8C%E6%96%AF%E6%89%98%E5%BC%97%C2%B7%E4%BA%9A%E5%8E%86%E5%B1%B1%E5%A4%A7" target="_blank" rel="noopener noreferrer">克里斯托佛·亚历山大</a>在其著作<a href="https://book.douban.com/subject/1157145/" target="_blank" rel="noopener noreferrer">《建筑模式语言》</a>中首次提出的。例如哥特式风格、巴洛克式建筑、中国古代园林风格等不同风格的建筑，都是不同的建筑<code>模式</code>。</p><p><code>埃里希·伽玛</code>、<code>约翰·弗利赛德斯</code>、<code>拉尔夫·约翰逊</code>和<code>理查德·赫尔姆</code>这四位作者受到了<code>模式</code>概念的启发，在1994年共同出版了<a href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener noreferrer">《设计模式：可复用面向对象软件的基础》</a>一书，将设计模式的概念应用到程序开发领域中。该书提出<code>23个</code>模式，以此来解决面向对象程序设计中的各种问题。</p><p>由于原书名太长，人们将其简称为<a href="https://www.geeksforgeeks.org/gang-of-four-gof-design-patterns/" target="_blank" rel="noopener noreferrer">四人组（Gang of Four，GoF）</a>的书，并且很快进一步简化为<code>GoF书</code>。</p><br><h2 id="设计模式所遵循的原则" tabindex="-1"><a class="header-anchor" href="#设计模式所遵循的原则"><span>设计模式所遵循的原则</span></a></h2><h3 id="代码复用原则" tabindex="-1"><a class="header-anchor" href="#代码复用原则"><span>代码复用原则</span></a></h3><p>代码复用可以说是<code>站在巨人的肩膀上</code>前行，这个<code>巨人</code>可以是别人，也可以是自己。</p><p>例如，当需要实现一个操作文件的功能时，如果已经有了现成的代码，大多数人都会毫不犹豫地去捡便宜。既然都已经有了，何必去费那个力气呢？时光宝贵，生命不应该浪费在重复的、毫无意义的事情上，不是吗？</p><p>但即使是想偷懒，也要知道组件间是否耦合？是否存在硬编码？是否需要满足特定的前提？......等诸如此类的问题。</p><p>就像GoF的作者之一埃里希·伽玛所说，<strong><mark>复用</mark></strong> 有三个层次。</p><ul><li><p>在最底层，可以<code>复用</code>类、类库、容器及其他。</p></li><li><p>在中间层，这就是<code>模式</code>，一组类的关系及其互动的方式的描述，这类似于一个针对具体问题的微型解决方案。</p></li><li><p>在最高层，复用一些已有的<code>框架</code>，例如<a href="https://spring.io/" target="_blank" rel="noopener noreferrer">Spring</a>、<a href="https://flask.palletsprojects.com/" target="_blank" rel="noopener noreferrer">Flask</a>、<a href="https://gin-gonic.com/" target="_blank" rel="noopener noreferrer">Gin</a>。</p></li></ul><h3 id="扩展性原则" tabindex="-1"><a class="header-anchor" href="#扩展性原则"><span>扩展性原则</span></a></h3><p><code>变化是唯一不变的事情</code>。</p><p>流程、功能、界面，甚至操作平台都会发生改变，例如从PC端迁移到移动端。</p><p>如果变化一次就要全部重写一次代码，那会把人逼疯。</p><p>不过这也有好的一面：至少还有人在关心这个破代码。</p><h3 id="封装变化原则" tabindex="-1"><a class="header-anchor" href="#封装变化原则"><span>封装变化原则</span></a></h3><p>为了将变更造成的影响最小化，就要想办法将这些可能发生变化的地方放给<code>封装</code>起来——例如，潜艇或军舰都被设计成一小段一小段的隔间，这些隔间之间都有防水闸门。潜艇或军舰遭受打击或爆破时，只要关闭隔间的闸门，就能立即阻隔涌进来的海水，将损失减到最小。</p><figure><img src="https://tianmazuo.com/technology/engineering/patterns/patterns-01.png" alt="潜艇的结构" tabindex="0" loading="lazy"><figcaption>潜艇的结构</figcaption></figure><p>对于软件开发也是一样。</p><p>例如一个电子商务网站，如果采用这种类似于潜艇结构的设计，那么就可以把会员、商铺、商品、购物车、支付、营销、统计等功能看作是一个个不同的<code>舱室</code>，即使支付功能暂时不可用，也不影响会员浏览商品与放入购物车。</p><h3 id="面向接口开发原则" tabindex="-1"><a class="header-anchor" href="#面向接口开发原则"><span>面向接口开发原则</span></a></h3><p>在很多不同的编程语言中，都对行为进行了抽象，这种抽象是独立于语言具体的实现机制而存在的。这些行为，对于语言来说，可以称之为<code>接口</code>。</p>',27),h=a(`<p>如果针对每个物种单独开发<code>吃东西</code>这一功能，恐怕工作量不小。</p><p>如果按照面向接口的开发原则，只需要将<code>吃东西</code>这一行为抽象成一个接口，然后针对不同物种执行不同的<code>具体动作</code>即可，这种<code>多态</code>机制大部分面向对象的编程语言都已具备——这至少免去了开发时每次都要重新创建<code>食物</code>这一重复性工作——这也符合上面所说的 <strong><mark>封装变化原则</mark></strong>。</p><h3 id="组合优于继承原则" tabindex="-1"><a class="header-anchor" href="#组合优于继承原则"><span>组合优于继承原则</span></a></h3><p>面向对象编程的便利性之一就是可以用继承来<code>偷懒</code>——子类直接复用父类的属性和方法而不必从头开始。</p><p>只是这种便利也是有代价的。</p><ul><li><p>子类无法增加或减少父类的方法，如果确实要这么做的话。</p></li><li><p>反过来，只要父类的方法有变化（方法名称、方法参数、方法数量等），子类都必须要跟着变——谁让你贪便宜的？</p></li><li><p>如果继承结构复杂庞大，会让人无从下手：因为哪怕改一个地方，就可能会有很多地方报异常。</p></li></ul><p><strong><mark>组合</mark></strong> 是代替 <strong><mark>继承</mark></strong> 的另一种选择。这有点类似于 <strong><mark>所有权</mark></strong> 与 <strong><mark>经营权</mark></strong> 的关系。</p><ul><li><p>继承代表 <strong><mark>is-a（是一个）</mark></strong> 的关系。例如，李四<code>是</code>张三的<code>一个</code>儿子。</p></li><li><p>组合代表 <strong><mark>has-a（有一个）</mark></strong> 的关系。例如，李四<code>有一个</code>叔叔叫王五。</p></li></ul><p>这种<code>既能利用对方功能而又不必担心对方死活</code>的方式，是非常利于开发的。</p><h3 id="单一职责原则" tabindex="-1"><a class="header-anchor" href="#单一职责原则"><span>单一职责原则</span></a></h3><p>这条原则的主要目的是减少复杂度，让不同的类和不同的方法各司其责：与其用300行代码来实现一个复杂的功能，不如用十几个职责清晰的接口（或方法）来拆分它。</p><p>这也是一种 <strong><mark>分而治之</mark></strong> 的策略，因为如果一个类或方法做了太多的事，那么当其中任何一点发生改变时，整个类或方法都必须跟着修改，这肯定是一个非常痛苦的过程。</p><h3 id="开闭原则" tabindex="-1"><a class="header-anchor" href="#开闭原则"><span>开闭原则</span></a></h3><p><strong><mark>开闭原则</mark></strong> 的意思是<code>对扩展开放，对修改关闭</code>，它的本意是在实现新功能的开发时，保持现有代码不变，至少是不会面临大规模地修改。</p><p>例如，如果某个电商平台有一个会员体系评判功能，改评价方法通过硬编码方式得出每个会员的等级。现在如果该电商平台接入了第三方授权，那么这个会员评价体系将不得不增加<code>if-else</code>分支条件，会对之前的源代码造成破坏。</p><p>如果按照<code>开闭原则</code>，那么只需要将评判方法抽象成为接口，新增加一个实现该接口的第三方会员评判类即可，原评判方法一行代码都不用改。</p><p>这就是所谓的<code>对扩展开放，对修改关闭</code>。</p><h3 id="里氏代换原则" tabindex="-1"><a class="header-anchor" href="#里氏代换原则"><span>里氏代换原则</span></a></h3><p>所谓 <strong><mark>里氏代换原则</mark></strong> 指的是类之间的兼容性问题，是否能够像操作（或传递）父类那样操作（或传递）子类。</p><p>这说的有点抽象，还是看看代码。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> LiskovSubstitutionPrinciple</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Animal</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Bird</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Animal</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Animal</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> eat</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Animal</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> animal</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        // TODO......</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果在上面代码中，<code>public Animal eat(Animal animal)</code>方法可以变成<code>public Bird eat(Bird bird)</code>，而功能不受任何影响，那么<code>Bird</code>类就符合 <strong><mark>里氏代换原则</mark></strong>。</p><p>之所有会有这么奇怪的原则存在，是因为在开发插件、类库或框架组件时，开发者无法预料开发出来的插件、类库或框架组件会被哪些客户端调用，即使知道也无法修改。</p><p>所以，必须遵守事先规定好的开发准则或技术规约，才能避免调用异常或失败。</p><p>这些开发准则或技术规约在某种程度上也扮演了父类的角色。</p><h3 id="接口隔离原则" tabindex="-1"><a class="header-anchor" href="#接口隔离原则"><span>接口隔离原则</span></a></h3><p>这个原则和 <strong><mark>单一职责原则</mark></strong> 说的是一体两面。</p><ul><li><p><strong><mark>单一职责原则</mark></strong> 是从开发者的角度来说的，尽量减少接口的功能复杂度，最好让接口一次只做一件事。</p></li><li><p><strong><mark>接口隔离原则</mark></strong> 则是从维护者的角度来说的，让接口只实现其必须具备的功能，它不需要的就剥离掉。</p></li></ul><p>例如，以共享单车来说，如果像下面那样设计功能结构，会给非电动的<code>共享单车</code>增加不必要的<code>充电</code>功能。</p><figure><img src="https://tianmazuo.com/technology/engineering/patterns/patterns-02.png" alt="隔离之前的接口" tabindex="0" loading="lazy"><figcaption>隔离之前的接口</figcaption></figure><p>如果按照 <strong><mark>接口隔离原则</mark></strong> 设计，那么它就应该是这个样子的。</p><figure><img src="https://tianmazuo.com/technology/engineering/patterns/patterns-03.png" alt="隔离之后的接口" tabindex="0" loading="lazy"><figcaption>隔离之后的接口</figcaption></figure><p>当然，这种设计也不是越细越好，太细了也会增加复杂度，需要折衷权衡。</p><h3 id="依赖倒置原则" tabindex="-1"><a class="header-anchor" href="#依赖倒置原则"><span>依赖倒置原则</span></a></h3><p>有的地方叫它 <strong><mark>控制反转原则</mark></strong>，但其实它们并不完全是一回事。</p><p><strong><mark>依赖倒置原则</mark></strong> 的核心意义是<code>高层不依赖底层，而底层依赖高层的抽象</code>。</p><p>这其实就等同于：</p><p>（高层的）业务逻辑 <code>决定</code>（中层的）技术路线 <code>决定</code>（底层的）技术实现方式。</p><blockquote><p>业务逻辑 &gt; 技术路线 &gt; 技术实现</p></blockquote><p>至于 <strong><mark>控制反转原则</mark></strong>，那只不过是框架的一种行为模式。</p><p>方向盘 <code>控制</code> 传动轴 <code>控制</code> 车轮子。</p><p>可以仔细体会一下 <strong><mark>控制反转原则</mark></strong> 和 <strong><mark>依赖倒置原则</mark></strong> 的这种差别。</p><br><h2 id="包含的内容" tabindex="-1"><a class="header-anchor" href="#包含的内容"><span>包含的内容</span></a></h2><p>所有关于模式的描述都会包括下面这些部分。</p><ul><li><p><code>模式概述</code>：简明扼要地说明该模式的作用。</p></li><li><p><code>问题</code>：面临的现实问题。</p></li><li><p><code>方案</code>：模式会提供什么样的解决方案，这样做的好处在哪。</p></li><li><p><code>结构</code>：模式的各个组成部分和它们之间的协作关系。</p></li><li><p><code>实现</code>：用不同编程语言实现的模式代码，例如<a href="https://www.oracle.com/java/technologies/downloads/archive/" target="_blank" rel="noopener noreferrer">Java</a>、<a href="https://www.python.org/" target="_blank" rel="noopener noreferrer">Python</a>或<a href="https://www.go.dev/" target="_blank" rel="noopener noreferrer">Go</a>。</p></li><li><p><code>适用场景</code>：哪些场合比较适用该模式，或哪些场合不适用。</p></li><li><p><code>优缺点</code>：模式的优缺点。</p></li><li><p><code>相关性</code>：该模式和其他模式的关系。</p></li></ul>`,46);function g(k,m){const n=t("RouteLink");return l(),r("div",null,[d,s("p",null,[e("以"),o(n,{to:"/technology/programming/java/#%E7%BB%A7%E6%89%BF"},{default:p(()=>[e("动物的继承结构")]),_:1}),e("来说，不同的物种其进食的方式是不一样的。哺乳类一般是咀嚼，大部分爬行类和几乎所有的鸟类都是生吞。")]),h])}const A=i(c,[["render",g],["__file","index.html.vue"]]),b=JSON.parse('{"path":"/technology/engineering/patterns/","title":"什么是“设计模式”","lang":"zh-CN","frontmatter":{"title":"什么是“设计模式”","icon":"compass-drafting","category":["软件工程","设计模式"],"tag":["软件工程","设计模式"],"date":"2022-09-20T00:00:00.000Z","isOriginal":true,"star":true,"description":"什么是“设计模式” 众所周知，算法、数据结构 和 设计模式一直都是软件开发中讨论话题非常多的几个领域。 如果说 数据结构 是一种对数据的组织形式（例如，可以把它看作一棵长满果实的果树）。 那么 算法 则给出了几种摘果子的方式（例如，深度优先摘取和广度优先摘取）。 而设计模式则是针对整个果园的一种采摘管理方式，它类似于蓝图，指明了低成本与高效的摘取方法。...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/technology/engineering/patterns/"}],["meta",{"property":"og:site_name","content":"添码座"}],["meta",{"property":"og:title","content":"什么是“设计模式”"}],["meta",{"property":"og:description","content":"什么是“设计模式” 众所周知，算法、数据结构 和 设计模式一直都是软件开发中讨论话题非常多的几个领域。 如果说 数据结构 是一种对数据的组织形式（例如，可以把它看作一棵长满果实的果树）。 那么 算法 则给出了几种摘果子的方式（例如，深度优先摘取和广度优先摘取）。 而设计模式则是针对整个果园的一种采摘管理方式，它类似于蓝图，指明了低成本与高效的摘取方法。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://tianmazuo.com/technology/engineering/patterns/patterns-01.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"添码座"}],["meta",{"property":"article:tag","content":"软件工程"}],["meta",{"property":"article:tag","content":"设计模式"}],["meta",{"property":"article:published_time","content":"2022-09-20T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"什么是“设计模式”\\",\\"image\\":[\\"https://tianmazuo.com/technology/engineering/patterns/patterns-01.png\\",\\"https://tianmazuo.com/technology/engineering/patterns/patterns-02.png\\",\\"https://tianmazuo.com/technology/engineering/patterns/patterns-03.png\\"],\\"datePublished\\":\\"2022-09-20T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"添码座\\",\\"url\\":\\"https://www.tianmazuo.com/about/\\"}]}"]]},"headers":[{"level":2,"title":"什么是“设计模式”","slug":"什么是-设计模式","link":"#什么是-设计模式","children":[]},{"level":2,"title":"设计模式所遵循的原则","slug":"设计模式所遵循的原则","link":"#设计模式所遵循的原则","children":[{"level":3,"title":"代码复用原则","slug":"代码复用原则","link":"#代码复用原则","children":[]},{"level":3,"title":"扩展性原则","slug":"扩展性原则","link":"#扩展性原则","children":[]},{"level":3,"title":"封装变化原则","slug":"封装变化原则","link":"#封装变化原则","children":[]},{"level":3,"title":"面向接口开发原则","slug":"面向接口开发原则","link":"#面向接口开发原则","children":[]},{"level":3,"title":"组合优于继承原则","slug":"组合优于继承原则","link":"#组合优于继承原则","children":[]},{"level":3,"title":"单一职责原则","slug":"单一职责原则","link":"#单一职责原则","children":[]},{"level":3,"title":"开闭原则","slug":"开闭原则","link":"#开闭原则","children":[]},{"level":3,"title":"里氏代换原则","slug":"里氏代换原则","link":"#里氏代换原则","children":[]},{"level":3,"title":"接口隔离原则","slug":"接口隔离原则","link":"#接口隔离原则","children":[]},{"level":3,"title":"依赖倒置原则","slug":"依赖倒置原则","link":"#依赖倒置原则","children":[]}]},{"level":2,"title":"包含的内容","slug":"包含的内容","link":"#包含的内容","children":[]}],"git":{},"readingTime":{"minutes":9.38,"words":2815},"filePathRelative":"technology/engineering/patterns/README.md","localizedDate":"2022年9月20日","excerpt":"<h2>什么是“设计模式”</h2>\\n<p>众所周知，<strong><mark>算法</mark></strong>、<strong><mark>数据结构</mark></strong> 和 <a href=\\"https://en.wikipedia.org/wiki/Design_Patterns\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">设计模式</a>一直都是软件开发中讨论话题非常多的几个领域。</p>\\n<ul>\\n<li>\\n<p>如果说 <strong><mark>数据结构</mark></strong> 是一种<code>对数据的组织形式</code>（例如，可以把它看作一棵长满果实的果树）。</p>\\n</li>\\n<li>\\n<p>那么 <strong><mark>算法</mark></strong> 则给出了几种<code>摘果子的方式</code>（例如，<code>深度优先摘取</code>和<code>广度优先摘取</code>）。</p>\\n</li>\\n<li>\\n<p>而<a href=\\"https://en.wikipedia.org/wiki/Design_Patterns\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">设计模式</a>则是针对整个果园的一种<code>采摘管理方式</code>，它类似于<code>蓝图</code>，指明了<code>低成本与高效</code>的摘取方法。</p>\\n</li>\\n</ul>","autoDesc":true}');export{A as comp,b as data};
