import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,o as d,d as l}from"./app-CiwSPZKD.js";const c={},t=l('<h2 id="redo机制" tabindex="-1"><a class="header-anchor" href="#redo机制"><span>redo机制</span></a></h2><p>如果<code>CRUD</code>的过程中数据库宕机，那么之前插入、更新或删除的数据就有可能会丢失。</p><p>由于随即磁盘读写的性能较差，因此更新缓存页的数据之后，并不会立即就写回磁盘去，这也容易导致数据丢失。</p><p>基于以上原因，引入了<code>redo log</code>日志机制。<a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>会在提交事务前，把对缓存页做过的数据修改以日志形式，顺序写入到磁盘上的<code>redo log</code>中。</p><p><code>redo log</code>日志格式大致为：<code>表空间号 + 数据页号 + 页内偏移量 + 被修改的字节值 + 具体值</code>。</p><p><a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>重启后，会将<code>redo log</code>中记录的未完成的内容重新执行一遍，然后再将缓存页的内容不定时地刷新到磁盘。</p><p><code>redo log</code>并不是一条条地写入直接往磁盘里写数据，一个<code>redo log block</code>大小为512字节，分为三个部分。</p><ul><li><p><code>header</code>头部：12字节。</p><ul><li><p><code>block no</code>：4字节。</p></li><li><p><code>data length</code>：2字节。</p></li><li><p><code>first record group</code>：2字节。</p></li><li><p><code>checkpoint no</code>：4字节。</p></li></ul></li><li><p><code>body</code>数据体：496字节。</p></li><li><p><code>trailer</code>尾部：4字节。</p></li></ul><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-28.png" alt="redo log block" tabindex="0" loading="lazy"><figcaption>redo log block</figcaption></figure><p><a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>先在内存里将<code>redo log</code>数据一条条地写入到<code>redo log block</code>的<code>body</code>数据块中，当内存里的一个<code>redo log block</code>写满，就会把这个<code>block</code>写入磁盘。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-29.png" alt="redo log block写入磁盘" tabindex="0" loading="lazy"><figcaption>redo log block写入磁盘</figcaption></figure><br><h2 id="redo-log-buffer" tabindex="-1"><a class="header-anchor" href="#redo-log-buffer"><span>redo log buffer</span></a></h2><p><code>redo log buffer</code>是专门用来缓冲<code>redo log</code>写入的一片连续内存空间。与<code>buffer pool</code>类似，刚启动时，<code>redo log buffer</code>也包含很多空的<code>redo log block</code>。</p><p><code>innodb_log_buffer_size</code>设置<code>redo log buffer</code>大小，默认16MB。要写<code>redo log</code>的时候，会从<code>redo log buffer</code>的第一个<code>redo log block</code>开始，写满之后继续写下一个。</p><p>如果所有<code>redo log block</code>都写满，就会强制把他们刷入磁盘。</p><figure><img src="https://tianmazuo.com/technology/database/mysql/mysql-30.png" alt="redo log buffer" tabindex="0" loading="lazy"><figcaption>redo log buffer</figcaption></figure><p><code>redo log buffer</code>的写入时机是。</p><ul><li><p>如果<code>redo log buffer</code>的日志已经超过其容量的一半（8MB），会把它们的数据写入磁盘文件。</p></li><li><p>事务提交时，必须把事务所对应的<code>redo log</code>所在的<code>redo log block</code>都写回磁盘文件。</p></li><li><p>后台<code>I/O</code>线程每隔1s就会把<code>redo log buffer</code>里的<code>redo log block</code>数据写回磁盘文件。</p></li><li><p><a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>关闭时，<code>redo log block</code>都会写入磁盘。</p></li></ul><p>默认情况下，<code>redo log</code>都会写入一个目录中的文件，可以通过<code>show variables like &#39;datadir&#39;;</code>来查看。</p><ul><li><p><code>innodb_log_group_home_dir</code>用来设置redo log目录。</p></li><li><p><code>innodb_log_file_size</code>可以限定每个redo log文件的大小，默认48MB。</p></li><li><p><code>innodb_log_files_in_group</code>指定文件数量，默认2个，即<code>ib_logfile0</code>和<code>ib_logfile1</code>。</p></li></ul><br><h2 id="undo-log" tabindex="-1"><a class="header-anchor" href="#undo-log"><span>undo log</span></a></h2><p>如果某个事务执行到了一半就回滚了，需要引入<code>undo log</code>。</p><p>对于<code>undo log</code>来说，<code>insert</code>对应<code>delete</code>，<code>update</code>对应<code>update</code>，由<code>Buffer Pool</code>记录<code>undo log</code>。</p><p>以<code>INSERT</code>语句为例，<code>undo log</code>包含下面的部分。</p><ul><li><p>日志起始位置。</p></li><li><p>主键的各列长度和值。</p></li><li><p>表ID。</p></li><li><p>日志编号。</p></li><li><p>日志类型。</p></li><li><p>日志结束位置。</p></li></ul>',27),r=[t];function a(p,i){return d(),e("div",null,r)}const s=o(c,[["render",a],["__file","log.html.vue"]]),m=JSON.parse('{"path":"/technology/database/mysql/log.html","title":"Log日志","lang":"zh-CN","frontmatter":{"title":"Log日志","icon":"table","category":["数据库","MySQL"],"tag":["数据库","MySQL"],"date":"2023-05-05T00:00:00.000Z","isOriginal":true,"star":true,"description":"redo机制 如果CRUD的过程中数据库宕机，那么之前插入、更新或删除的数据就有可能会丢失。 由于随即磁盘读写的性能较差，因此更新缓存页的数据之后，并不会立即就写回磁盘去，这也容易导致数据丢失。 基于以上原因，引入了redo log日志机制。MySQL会在提交事务前，把对缓存页做过的数据修改以日志形式，顺序写入到磁盘上的redo log中。 redo ...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/technology/database/mysql/log.html"}],["meta",{"property":"og:site_name","content":"添码座"}],["meta",{"property":"og:title","content":"Log日志"}],["meta",{"property":"og:description","content":"redo机制 如果CRUD的过程中数据库宕机，那么之前插入、更新或删除的数据就有可能会丢失。 由于随即磁盘读写的性能较差，因此更新缓存页的数据之后，并不会立即就写回磁盘去，这也容易导致数据丢失。 基于以上原因，引入了redo log日志机制。MySQL会在提交事务前，把对缓存页做过的数据修改以日志形式，顺序写入到磁盘上的redo log中。 redo ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://tianmazuo.com/technology/database/mysql/mysql-28.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"添码座"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:published_time","content":"2023-05-05T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Log日志\\",\\"image\\":[\\"https://tianmazuo.com/technology/database/mysql/mysql-28.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-29.png\\",\\"https://tianmazuo.com/technology/database/mysql/mysql-30.png\\"],\\"datePublished\\":\\"2023-05-05T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"添码座\\",\\"url\\":\\"https://www.tianmazuo.com/about/\\"}]}"]]},"headers":[{"level":2,"title":"redo机制","slug":"redo机制","link":"#redo机制","children":[]},{"level":2,"title":"redo log buffer","slug":"redo-log-buffer","link":"#redo-log-buffer","children":[]},{"level":2,"title":"undo log","slug":"undo-log","link":"#undo-log","children":[]}],"git":{},"readingTime":{"minutes":2.58,"words":774},"filePathRelative":"technology/database/mysql/log.md","localizedDate":"2023年5月5日","excerpt":"<h2>redo机制</h2>\\n<p>如果<code>CRUD</code>的过程中数据库宕机，那么之前插入、更新或删除的数据就有可能会丢失。</p>\\n<p>由于随即磁盘读写的性能较差，因此更新缓存页的数据之后，并不会立即就写回磁盘去，这也容易导致数据丢失。</p>\\n<p>基于以上原因，引入了<code>redo log</code>日志机制。<a href=\\"https://www.mysql.com\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">MySQL</a>会在提交事务前，把对缓存页做过的数据修改以日志形式，顺序写入到磁盘上的<code>redo log</code>中。</p>","autoDesc":true}');export{s as comp,m as data};
