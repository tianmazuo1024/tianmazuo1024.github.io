import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as l,c as r,a as i,e,b as t,w as n,d as s,o as c}from"./app-B5m7CcSj.js";const p={},d=s('<h2 id="动态时间片" tabindex="-1"><a class="header-anchor" href="#动态时间片"><span>动态时间片</span></a></h2><p>类似<code>近1小时内用户的登录次数多于3次</code>这样的风控指标，本质上是一种<code>风控关系表达式</code>，它由<code>左变量</code>、<code>关系运算符</code>和<code>右变量</code>（或<code>阈值</code>）组成，如果把它用另外一种方式展现出来就是这样。</p><figure><img src="https://tianmazuo.com/application/case/risk/risk-05.png" alt="风控指标表达式" tabindex="0" loading="lazy"><figcaption>风控指标表达式</figcaption></figure><p>对于这种风控指标的计算来说，真正的难点不在于计算本身，而在于 <strong><mark><code>如何快速且准确地取得指定时间片的数据</code></mark></strong>。</p><p>因为很显然，条件中的<code>近1小时内</code>，它绝不是某个固定时间点开始后的<code>1小时</code>，而是从当前时间开始往回倒推的<code>1小时</code>。</p><p>也就是说，这个<code>时间片</code>是不断动态变化的：每过去1秒，往回推的<code>时间片</code>就要少计算1秒。</p><figure><img src="https://tianmazuo.com/application/case/risk/risk-06.png" alt="动态变化的时间片" tabindex="0" loading="lazy"><figcaption>动态变化的时间片</figcaption></figure><ul><li><p>在<code>06:00</code>时，<code>近1小时</code>指的是<code>05:00 ~ 06:00</code>。</p></li><li><p>在<code>07:00</code>时，<code>近1小时</code>指的是<code>06:00 ~ 07:00</code>。</p></li><li><p>在<code>08:00</code>时，<code>近1小时</code>指的是<code>07:00 ~ 08:00</code>。</p></li><li><p>......</p></li></ul><p>对于这种动态变化的<code>时间片</code>，难道针对每一个不同的时间片，都要采集该时间片内的全部数据重新计算一次吗？</p><ul><li><p>要计算<code>2024-01-02 00:00:01</code>一天内的登录数据，就把<code>2024-01-01 00:00:01 ~ 2024-01-02 00:00:01</code>时间片内的所有数据全都读取出来计算。</p></li><li><p>要计算<code>2024-01-02 00:00:02</code>一天内的登录数据，就把<code>2024-01-01 00:00:02 ~ 2024-01-02 00:00:02</code>时间片内的所有数据全都读取出来计算。</p></li></ul><p><a href="https://flink.apache.org/" target="_blank" rel="noopener noreferrer">Flink</a>在实时计算方面的性能虽然很高，但这种统计方式显然极其低效。</p><br><h2 id="时间窗口机制" tabindex="-1"><a class="header-anchor" href="#时间窗口机制"><span>时间窗口机制</span></a></h2>',13),h=i("a",{href:"https://flink.apache.org/",target:"_blank",rel:"noopener noreferrer"},"Flink",-1),g=i("code",null,"窗口",-1),k=i("p",null,[e("假设"),i("a",{href:"https://flink.apache.org/",target:"_blank",rel:"noopener noreferrer"},"Flink"),e("中保存有过去6分钟的登录数据序列。")],-1),m=i("figure",null,[i("img",{src:"https://tianmazuo.com/application/case/risk/risk-07.png",alt:"过去6分钟的登录数据序列",tabindex:"0",loading:"lazy"}),i("figcaption",null,"过去6分钟的登录数据序列")],-1),f=i("a",{href:"https://flink.apache.org/",target:"_blank",rel:"noopener noreferrer"},"Flink",-1),u=s(`<p>它可以是每1分钟统计一次。</p><figure><img src="https://tianmazuo.com/application/case/risk/risk-08.png" alt="每1分钟统计一次登录次数" tabindex="0" loading="lazy"><figcaption>每1分钟统计一次登录次数</figcaption></figure><p>也可以是每2分钟统计一次。</p><figure><img src="https://tianmazuo.com/application/case/risk/risk-09.png" alt="每2分钟统计一次登录次数" tabindex="0" loading="lazy"><figcaption>每2分钟统计一次登录次数</figcaption></figure><p>可以看到，统计结果依据<code>窗口步长</code>的不同而不同。</p><p>如果数据更多，统计粒度更大（例如，按<code>小时</code>或按<code>天</code>），其结果也是类似的。</p><p>这种用来存储风控数据的时间窗口，有一个专门的名称：<code>指标采样窗口</code>。</p><figure><img src="https://tianmazuo.com/application/case/risk/risk-10.png" alt="指标采样窗口" tabindex="0" loading="lazy"><figcaption>指标采样窗口</figcaption></figure><p>这种窗口的粒度可大可小：可以是分钟，可以是小时，也可以是天，完全根据业务需求而定。一般来说，最小粒度设为<code>分钟</code>已经足够了。</p><br><h2 id="指标数据计算" tabindex="-1"><a class="header-anchor" href="#指标数据计算"><span>指标数据计算</span></a></h2><p>有了解决<code>动态时间片</code>的<code>时间窗口机制</code>，那该怎样实现它呢？也就是对于<code>任意时间片</code>来说，该如何存储和查询这些数据，以便<code>快速</code>地执行风控指标计算呢？</p><h3 id="存储指标采样" tabindex="-1"><a class="header-anchor" href="#存储指标采样"><span>存储指标采样</span></a></h3><p>对于存储来说，<a href="https://www.clickhouse.com/" target="_blank" rel="noopener noreferrer">Clickhouse</a>会在后台不停地计算每个用户每分钟的登录次数，然后作为<code>指标采样数据</code>保存到<a href="https://www.redis.io/" target="_blank" rel="noopener noreferrer">Redis</a>，这些数据相对于<a href="https://flink.apache.org/" target="_blank" rel="noopener noreferrer">Flink</a>来说是一种<code>预聚合</code>（或<code>轻度聚合</code>）数据，因为它为<a href="https://flink.apache.org/" target="_blank" rel="noopener noreferrer">Flink</a>提供了一些现成的可以直接拿来就用的结果集。</p><ul><li><p>如果在<code>06:01 ~ 06:02</code>之间有过登录，那么<a href="https://www.clickhouse.com/" target="_blank" rel="noopener noreferrer">Clickhouse</a>就会把统计出来的数据保存到<code>06:02</code>这个时间点上。</p></li><li><p>如果在<code>06:01 ~ 06:02</code>之间没有登录，那么<code>06:02</code>这个时间点上登录的次数就是0。</p></li></ul><p>所以，在<a href="https://www.redis.io/" target="_blank" rel="noopener noreferrer">Redis</a>中保存的登录数据序列有可能是这样的。</p><figure><img src="https://tianmazuo.com/application/case/risk/risk-11.png" alt="Redis中保存的登录数据序列" tabindex="0" loading="lazy"><figcaption>Redis中保存的登录数据序列</figcaption></figure><p>为什么用<a href="https://www.redis.io/" target="_blank" rel="noopener noreferrer">Redis</a>保存数据呢？</p><ul><li><p>这种针对每个用户的，且每分钟都要保存一次的<code>KV键值对</code>数据，是不适合用<a href="https://www.mysql.com" target="_blank" rel="noopener noreferrer">MySQL</a>来存储的。</p></li><li><p>作为分布式缓存，<a href="https://www.redis.io/" target="_blank" rel="noopener noreferrer">Redis</a>的读写性能非常高，而且有独特的数据过期失效机制。</p></li></ul><p><a href="https://www.clickhouse.com/" target="_blank" rel="noopener noreferrer">Clickhouse</a>会将<code>时间点</code>本身作为<code>key</code>的一部分保存到<a href="https://www.redis.io/" target="_blank" rel="noopener noreferrer">Redis</a>，所以它的<code>key</code>是这样的。</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># Redis Key = 指标ID:分组ID:指标维度:计算方式:时间戳</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># 1             ： 指标ID</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># 0             ： 分组ID，值可以是userid</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># 5ml           ： 指标维度，5分钟内的登录次数，也可以是3分钟内的登录次数或别的指标</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># sum           ： 计算方式为求和，也可以是其他方式</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># 1704060060000 ： 2024-01-01 06:01:00的时间戳，单位毫秒</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># 300           ： 过期时间300秒</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; SETEX 1:0:1ml:sum:1704060060000 300 5</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过这种<code>key</code>的组合方式，就把每1分钟内对应的登录数据保存到了<a href="https://www.redis.io/" target="_blank" rel="noopener noreferrer">Redis</a>。</p><p>而且由于存在数据过期机制，<a href="https://www.redis.io/" target="_blank" rel="noopener noreferrer">Redis</a>中的数据也会随着时间片一同更新。</p><h3 id="读取指标采样" tabindex="-1"><a class="header-anchor" href="#读取指标采样"><span>读取指标采样</span></a></h3><p>假设当前时间是早上<code>10:00</code>，需要获取账号最近5分钟内，也就是<code>09:55 ~ 10:00</code>之间的登录次数，数据如下。</p><figure><img src="https://tianmazuo.com/application/case/risk/risk-12.png" alt="第一种情况：时间差超过5分钟" tabindex="0" loading="lazy"><figcaption>第一种情况：时间差超过5分钟</figcaption></figure><p>这时候，会发现最接近的<code>10:00</code>时间也只有<code>09:52</code>那一时间点的采样数据，而这个时间点并没有<code>≥ 09:55</code>，所以得到最近5分钟内的登录次数为0——这是一种情况。</p><p>第二种情况是在<code>09:55 ~ 10:00</code>之间有登录数据。</p><figure><img src="https://tianmazuo.com/application/case/risk/risk-13.png" alt="第二种情况：时间差小于或等于5分钟" tabindex="0" loading="lazy"><figcaption>第二种情况：时间差小于或等于5分钟</figcaption></figure><p>可以看到，有2条数据的存储时间点是<code>≥ 09:55</code>的。</p><p>所以，按照<a href="https://www.redis.io/" target="_blank" rel="noopener noreferrer">Redis</a><code>key</code>的生成机制，可以这样读取它们的值。</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># 读取2024-01-01 09:55:00的数据</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; GET 1:0:1ml:sum:1704074100000</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">3</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># 读取2024-01-01 09:56:00的数据</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; GET 1:0:1ml:sum:1704074160000</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>至于如何通过时间计算函数来判断和读取<a href="https://www.redis.io/" target="_blank" rel="noopener noreferrer">Redis</a>中的数据，就完全是<a href="https://www.oracle.com/java/technologies/downloads/archive/" target="_blank" rel="noopener noreferrer">Java</a>的事了。</p><p>另外，使用<a href="https://www.clickhouse.com/" target="_blank" rel="noopener noreferrer">Clickhouse</a>将数据保存到<a href="https://www.redis.io/" target="_blank" rel="noopener noreferrer">Redis</a>时，是用<code>String</code>、<code>List</code>还是<code>HSet</code>，完全可以视情况而定。</p>`,34);function b(y,w){const a=l("RouteLink");return c(),r("div",null,[d,i("p",null,[h,e("中有四种从数据流中读取数据的"),g,e("机制，分别是："),t(a,{to:"/technology/bigdata/flink/tumbling.html#tumblingwindow-%E6%BB%9A%E5%8A%A8%E7%AA%97%E5%8F%A3"},{default:n(()=>[e("滚动窗口")]),_:1}),e("、"),t(a,{to:"/technology/bigdata/flink/sliding.html"},{default:n(()=>[e("滑动窗口")]),_:1}),e("、"),t(a,{to:"/technology/bigdata/flink/sessionglobal.html"},{default:n(()=>[e("会话窗口和全局窗口")]),_:1}),e("。")]),i("p",null,[e("尤其是"),t(a,{to:"/technology/bigdata/flink/tumbling.html#tumblingwindow-%E6%BB%9A%E5%8A%A8%E7%AA%97%E5%8F%A3"},{default:n(()=>[e("滚动窗口")]),_:1}),e("和"),t(a,{to:"/technology/bigdata/flink/sliding.html"},{default:n(()=>[e("滑动窗口")]),_:1}),e("，完全是为读取动态时间片中的数据而设计的机制。")]),k,m,i("p",null,[e("如果现在需要统计过去每2分钟内的登录数据，就可以仿效"),f,e("的"),t(a,{to:"/technology/bigdata/flink/sliding.html"},{default:n(()=>[e("滑动窗口")]),_:1}),e("机制进行。")]),u])}const v=o(p,[["render",b],["__file","sampling.html.vue"]]),z=JSON.parse('{"path":"/application/case/risk/sampling.html","title":"指标采样设计思路","lang":"zh-CN","frontmatter":{"title":"指标采样设计思路","icon":"shoe-prints","category":["案例","大数据风控"],"tag":["案例","大数据风控","Clickhouse","Redis","Flink"],"date":"2024-03-05T00:00:00.000Z","isOriginal":true,"star":true,"description":"动态时间片 类似近1小时内用户的登录次数多于3次这样的风控指标，本质上是一种风控关系表达式，它由左变量、关系运算符和右变量（或阈值）组成，如果把它用另外一种方式展现出来就是这样。 风控指标表达式风控指标表达式 对于这种风控指标的计算来说，真正的难点不在于计算本身，而在于 如何快速且准确地取得指定时间片的数据。 因为很显然，条件中的近1小时内，它绝不是某...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/application/case/risk/sampling.html"}],["meta",{"property":"og:site_name","content":"添码座"}],["meta",{"property":"og:title","content":"指标采样设计思路"}],["meta",{"property":"og:description","content":"动态时间片 类似近1小时内用户的登录次数多于3次这样的风控指标，本质上是一种风控关系表达式，它由左变量、关系运算符和右变量（或阈值）组成，如果把它用另外一种方式展现出来就是这样。 风控指标表达式风控指标表达式 对于这种风控指标的计算来说，真正的难点不在于计算本身，而在于 如何快速且准确地取得指定时间片的数据。 因为很显然，条件中的近1小时内，它绝不是某..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://tianmazuo.com/application/case/risk/risk-05.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"添码座"}],["meta",{"property":"article:tag","content":"案例"}],["meta",{"property":"article:tag","content":"大数据风控"}],["meta",{"property":"article:tag","content":"Clickhouse"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"Flink"}],["meta",{"property":"article:published_time","content":"2024-03-05T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"指标采样设计思路\\",\\"image\\":[\\"https://tianmazuo.com/application/case/risk/risk-05.png\\",\\"https://tianmazuo.com/application/case/risk/risk-06.png\\",\\"https://tianmazuo.com/application/case/risk/risk-07.png\\",\\"https://tianmazuo.com/application/case/risk/risk-08.png\\",\\"https://tianmazuo.com/application/case/risk/risk-09.png\\",\\"https://tianmazuo.com/application/case/risk/risk-10.png\\",\\"https://tianmazuo.com/application/case/risk/risk-11.png\\",\\"https://tianmazuo.com/application/case/risk/risk-12.png\\",\\"https://tianmazuo.com/application/case/risk/risk-13.png\\"],\\"datePublished\\":\\"2024-03-05T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"添码座\\",\\"url\\":\\"https://www.tianmazuo.com/about/\\"}]}"]]},"headers":[{"level":2,"title":"动态时间片","slug":"动态时间片","link":"#动态时间片","children":[]},{"level":2,"title":"时间窗口机制","slug":"时间窗口机制","link":"#时间窗口机制","children":[]},{"level":2,"title":"指标数据计算","slug":"指标数据计算","link":"#指标数据计算","children":[{"level":3,"title":"存储指标采样","slug":"存储指标采样","link":"#存储指标采样","children":[]},{"level":3,"title":"读取指标采样","slug":"读取指标采样","link":"#读取指标采样","children":[]}]}],"git":{},"readingTime":{"minutes":5.76,"words":1729},"filePathRelative":"application/case/risk/sampling.md","localizedDate":"2024年3月5日","excerpt":"<h2>动态时间片</h2>\\n<p>类似<code>近1小时内用户的登录次数多于3次</code>这样的风控指标，本质上是一种<code>风控关系表达式</code>，它由<code>左变量</code>、<code>关系运算符</code>和<code>右变量</code>（或<code>阈值</code>）组成，如果把它用另外一种方式展现出来就是这样。</p>\\n<figure><img src=\\"https://tianmazuo.com/application/case/risk/risk-05.png\\" alt=\\"风控指标表达式\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>风控指标表达式</figcaption></figure>","autoDesc":true}');export{v as comp,z as data};
